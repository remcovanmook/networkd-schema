{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "https://systemd.io/schemas/v244/network.json",
  "title": "Systemd network Configuration (v244)",
  "type": "object",
  "additionalProperties": false,
  "definitions": {
    "mac_address": {
      "type": "string",
      "description": "MAC Address (Hex separated by colons or hyphens)",
      "pattern": "^([0-9a-fA-F]{2}[:-]){5}([0-9a-fA-F]{2})$",
      "title": "MAC Address",
      "examples": [
        "00:11:22:33:44:55"
      ]
    },
    "ipv4_address": {
      "type": "string",
      "description": "IPv4 Address",
      "format": "ipv4",
      "title": "IPv4 Address",
      "examples": [
        "192.168.1.1"
      ]
    },
    "ipv6_address": {
      "type": "string",
      "description": "IPv6 Address",
      "format": "ipv6",
      "title": "IPv6 Address",
      "examples": [
        "2001:db8::1"
      ]
    },
    "ip_address": {
      "description": "IPv4 or IPv6 Address",
      "oneOf": [
        {
          "$ref": "#/definitions/ipv4_address"
        },
        {
          "$ref": "#/definitions/ipv6_address"
        }
      ]
    },
    "ipv4_prefix": {
      "type": "string",
      "description": "IPv4 Address with Prefix Length (CIDR), e.g., 192.168.1.1/24",
      "pattern": "^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/(3[0-2]|[1-2]?[0-9]|[0-9])$",
      "title": "IPv4 CIDR",
      "examples": [
        "192.168.1.0/24"
      ]
    },
    "ipv6_prefix": {
      "type": "string",
      "description": "IPv6 Address with Prefix Length (CIDR), e.g., 2001:db8::1/64",
      "pattern": "^([0-9a-fA-F]{1,4}:){1,7}:?([0-9a-fA-F]{1,4}:?)*\\/(12[0-8]|1[0-1][0-9]|[1-9]?[0-9]|[0-9])$",
      "title": "IPv6 CIDR",
      "examples": [
        "2001:db8::/64"
      ]
    },
    "ip_prefix": {
      "description": "IPv4 or IPv6 Prefix (CIDR)",
      "oneOf": [
        {
          "$ref": "#/definitions/ipv4_prefix"
        },
        {
          "$ref": "#/definitions/ipv6_prefix"
        }
      ]
    },
    "filename": {
      "type": "string",
      "description": "Filesystem path",
      "format": "uri-reference",
      "title": "File Path",
      "examples": [
        "/etc/issue"
      ]
    },
    "seconds": {
      "type": "string",
      "pattern": "^[0-9]+(\\.[0-9]+)?(us|ms|s|min|h|d|w|M|y)?$",
      "format": "duration",
      "description": "Time duration (e.g. 5s, 1min, 500ms)",
      "title": "Duration",
      "examples": [
        "5s",
        "100ms",
        "1min"
      ]
    },
    "bytes": {
      "description": "Size in bytes (Integer or String with suffix B, K, M, G, T, P, E)",
      "oneOf": [
        {
          "type": "integer",
          "minimum": 0
        },
        {
          "type": "string",
          "pattern": "^[0-9]+(\\s*[KMGTPE]i?B?)?$"
        }
      ],
      "title": "Size in Bytes",
      "examples": [
        "1G",
        "512M",
        "1024"
      ],
      "format": "bytes"
    },
    "MTUBytes": {
      "description": "Maximum Transmission Unit (MTU) in bytes",
      "oneOf": [
        {
          "type": "integer",
          "minimum": 68,
          "maximum": 65535
        },
        {
          "type": "string",
          "pattern": "^[0-9]+(\\s*[KMGTPE]i?)?$",
          "format": "bytes"
        }
      ],
      "title": "MTU (Bytes)",
      "examples": [
        "1500",
        "9000"
      ],
      "format": "bytes"
    },
    "MTUv6Bytes": {
      "description": "Maximum Transmission Unit (MTU) in bytes",
      "oneOf": [
        {
          "type": "integer",
          "minimum": 1280,
          "maximum": 65535
        },
        {
          "type": "string",
          "pattern": "^[0-9]+(\\s*[KMGTPE]i?)?$"
        }
      ],
      "title": "IPv6 MTU (Bytes)",
      "examples": [
        "1280",
        "1500"
      ],
      "format": "bytes"
    },
    "rate": {
      "description": "Data rate in bits per second (e.g. 1G, 100M, 500K)",
      "oneOf": [
        {
          "type": "integer",
          "minimum": 0
        },
        {
          "type": "string",
          "pattern": "^[0-9]+(\\.[0-9]+)?(\\s*[KMGTPE]i?)?$"
        }
      ],
      "title": "Data Rate",
      "examples": [
        "1G",
        "100M"
      ]
    },
    "percentage": {
      "type": "string",
      "pattern": "^[0-9]+(\\.[0-9]+)?%$",
      "description": "Percentage value (e.g. 10%, 0.5%)",
      "title": "Percentage",
      "examples": [
        "10%",
        "0.5%"
      ],
      "format": "percent"
    },
    "vlan_id": {
      "type": "integer",
      "minimum": 0,
      "maximum": 4094,
      "description": "The VLAN ID. An integer in the range 0...4094.",
      "title": "VLAN ID",
      "examples": [
        1,
        100,
        4094
      ]
    },
    "qdisc_handle": {
      "type": "string",
      "pattern": "^[0-9a-fA-F]{1,4}:([0-9a-fA-F]{1,4})?$",
      "description": "Queueing Discipline handle (hex major:minor).",
      "title": "QDisc Handle",
      "examples": [
        "1:0",
        "10:"
      ]
    },
    "qdisc_parent": {
      "description": "Queueing Discipline parent.",
      "oneOf": [
        {
          "$ref": "#/definitions/qdisc_handle"
        },
        {
          "type": "string",
          "enum": [
            "root",
            "clsact",
            "ingress",
            "egress"
          ]
        }
      ],
      "title": "QDisc Parent",
      "examples": [
        "root",
        "ingress",
        "1:1"
      ]
    },
    "uint8": {
      "type": "integer",
      "minimum": 0,
      "maximum": 255,
      "description": "Unsigned 8-bit integer (0...255).",
      "title": "Integer (8-bit)",
      "examples": [
        128
      ]
    },
    "uint16": {
      "type": "integer",
      "minimum": 0,
      "maximum": 65535,
      "description": "Unsigned 16-bit integer (0...65535).",
      "title": "Integer (16-bit)",
      "examples": [
        1024
      ]
    },
    "uint32": {
      "type": "integer",
      "minimum": 0,
      "maximum": 4294967294,
      "description": "Unsigned 32-bit integer (0...4294967294).",
      "title": "Integer (32-bit)",
      "examples": [
        65535
      ]
    }
  },
  "properties": {
    "Match": {
      "type": "object",
      "description": "[Match] section configuration",
      "properties": {
        "MACAddress": {
          "allOf": [
            {
              "$ref": "#/definitions/mac_address"
            }
          ],
          "description": "A whitespace-separated list of hardware addresses.",
          "title": "MAC Address Match",
          "examples": [
            "12:34:56:78:9a:bc",
            "00:11:22:33:44:55 66:77:88:99:aa:bb"
          ]
        },
        "Path": {
          "allOf": [
            {
              "$ref": "#/definitions/filename"
            }
          ],
          "description": "The path to the device.",
          "title": "Path"
        },
        "Driver": {
          "type": "string",
          "title": "Driver"
        },
        "Type": {
          "type": "string",
          "enum": [
            "blackhole",
            "goto",
            "nop",
            "prohibit",
            "table",
            "unreachable"
          ],
          "default": "table",
          "description": "Specifies Routing Policy Database (RPDB) rule type. When 'goto', the target priority must be specified in GoTo=. Defaults to 'table'.",
          "title": "Type",
          "examples": [
            "global",
            "link",
            "host"
          ]
        },
        "WLANInterfaceType": {
          "type": "string",
          "pattern": "^!?\\s*(ad-hoc|ap|ap-vlan|mesh-point|monitor|nan|ocb|p2p-client|p2p-device|p2p-go|station|wds)(\\s+(ad-hoc|ap|ap-vlan|mesh-point|monitor|nan|ocb|p2p-client|p2p-device|p2p-go|station|wds))*\\s*$",
          "description": "A whitespace-separated list of wireless network type. If the list is prefixed with a \"!\", the test is inverted.",
          "title": "WLAN Interface Type"
        },
        "SSID": {
          "type": "string",
          "description": "A whitespace-separated list of shell-style globs matching the SSID of the currently connected wireless LAN. If the list is prefixed with a \"!\", the test is inverted.",
          "title": "SSID"
        },
        "BSSID": {
          "type": "string",
          "pattern": "^!?\\s*([0-9a-fA-F]{2}[:-]){5}([0-9a-fA-F]{2})(\\s+([0-9a-fA-F]{2}[:-]){5}([0-9a-fA-F]{2}))*\\s*$",
          "description": "A whitespace-separated list of hardware address of the currently connected wireless LAN. Use full colon-, hyphen- or dot-delimited hexadecimal. See the example in MACAddress=. This option may appear more than once, in which case the lists are merged. If the empty string is assigned to this option, the list is reset.",
          "title": "BSSID"
        },
        "Name": {
          "type": "string",
          "description": "A whitespace-separated list of shell-style globs matching the device name, as exposed by the udev property 'INTERFACE', or device's alternative names. If the list is prefixed with a \"!\", the test is inverted.",
          "title": "Name",
          "examples": [
            "eth0",
            "br0"
          ]
        },
        "Property": {
          "type": "string",
          "title": "Property"
        },
        "Host": {
          "type": "string",
          "title": "Host"
        },
        "Virtualization": {
          "type": "string",
          "title": "Virtualization"
        },
        "KernelCommandLine": {
          "type": "string",
          "title": "Kernel Command Line"
        },
        "KernelVersion": {
          "type": "string",
          "title": "Kernel Version"
        },
        "Architecture": {
          "type": "string",
          "title": "Architecture"
        }
      },
      "additionalProperties": false,
      "required": [
        "Type"
      ],
      "title": "Match"
    },
    "Link": {
      "type": "object",
      "description": "[Link] section configuration",
      "properties": {
        "MACAddress": {
          "allOf": [
            {
              "$ref": "#/definitions/mac_address"
            }
          ],
          "description": "The hardware address to set for the device.",
          "title": "Set MAC Address",
          "examples": [
            "12:34:56:78:9a:bc",
            "none"
          ]
        },
        "MTUBytes": {
          "allOf": [
            {
              "$ref": "#/definitions/MTUBytes"
            }
          ],
          "description": "The maximum transmission unit in bytes to set for the device. The usual suffixes K, M, G, are supported and are understood to the base of 1024. Note that if IPv6 is enabled on the interface, and the MTU is chosen below 1280 (the minimum MTU for IPv6) it will automatically be increased to this value.",
          "title": "MTU (Bytes)",
          "examples": [
            "1500",
            "9000",
            "auto"
          ]
        },
        "ARP": {
          "type": "boolean",
          "description": "If set to true, the IPv4 ARP (low-level Address Resolution Protocol) and IPv6 NDP (Neighbor Discovery Protocol) for this interface are enabled. When unset, the kernel's default will be used. For example, disabling ARP is useful when creating multiple MACVLAN or VLAN virtual interfaces atop a single lower-level physical interface, which will then only serve as a link/\"bridge\" device aggregating traffic to the same physical link and not participate in the network otherwise. Defaults to unset.",
          "title": "ARP",
          "examples": [
            "yes",
            "no"
          ]
        },
        "Multicast": {
          "type": "boolean",
          "description": "If set to true, the multicast flag on the device is enabled. Defaults to unset.",
          "title": "Multicast",
          "examples": [
            "yes",
            "no"
          ]
        },
        "AllMulticast": {
          "type": "boolean",
          "description": "If set to true, the driver retrieves all multicast packets from the network. This happens when multicast routing is enabled. Defaults to unset.",
          "title": "All Multicast",
          "examples": [
            "yes",
            "no"
          ]
        },
        "Unmanaged": {
          "type": "boolean",
          "default": false,
          "description": "When 'yes', no attempts are made to bring up or configure matching links, equivalent to when there are no matching network files. Defaults to 'no'. This is useful for preventing later matching network files from interfering with certain interfaces that are fully controlled by other applications.",
          "title": "Unmanaged",
          "examples": [
            "yes",
            "no"
          ]
        },
        "RequiredForOnline": {
          "type": "string",
          "default": "yes",
          "description": ", a minimum operational state (e.g., 'carrier'), or a range of operational state separated with a colon (e.g., 'degraded:routable'). Please see networkctl1 for possible operational states. When 'yes', the network is deemed required when determining whether the system is online (including when running systemd-networkd-wait-online). When 'no', the network is ignored when determining the online state. When a minimum operational state and an optional maximum operational state are set, systemd-networkd-wait-online deems that the interface is online when the operational state is in the specified range. Defaults to 'yes' when ActivationPolicy= is not set, or set to 'up', 'always-up', or 'bound'. Defaults to 'no' when ActivationPolicy= is set to 'manual' or 'down'. This is forced to 'no' when ActivationPolicy= is set to 'always-down'. The network will be brought up normally (as configured by ActivationPolicy=), but in the event that there is no address being assigned by DHCP or the cable is not plugged in, the link will simply remain offline and be skipped automatically by systemd-networkd-wait-online if 'RequiredForOnline=no'. The boolean value 'yes' is translated as follows; 'CAN devices' 'carrier', 'Master devices, e.g. bond or bridge' 'degraded-carrier' with RequiredFamilyForOnline=any, 'Bonding port interfaces' 'enslaved', 'Other interfaces' 'degraded'. 'carrier', 'degraded-carrier' with RequiredFamilyForOnline=any, 'enslaved', 'degraded'. This setting can be overridden by the command line option for systemd-networkd-wait-online. See systemd-networkd-wait-online.service8 for more details.",
          "title": "Required For Online",
          "examples": [
            "yes",
            "no",
            "carrier",
            "degraded:routable"
          ]
        }
      },
      "additionalProperties": false,
      "title": "Link"
    },
    "Network": {
      "type": "object",
      "description": "[Network] section configuration",
      "properties": {
        "Description": {
          "type": "string",
          "description": "A description of the device. This is only used for presentation purposes.",
          "title": "Description",
          "examples": [
            "My Interface",
            "Uplink to ISP"
          ]
        },
        "Bond": {
          "type": "string",
          "title": "Bond"
        },
        "Bridge": {
          "type": "string",
          "title": "Bridge"
        },
        "VRF": {
          "type": "string",
          "title": "VRF"
        },
        "IPVLAN": {
          "type": "string",
          "title": "IPVLAN"
        },
        "IPVTAP": {
          "type": "string",
          "title": "IPVTAP"
        },
        "L2TP": {
          "type": "string",
          "title": "L2 TP"
        },
        "MACsec": {
          "type": "string",
          "title": "MA Csec"
        },
        "MACVLAN": {
          "type": "string",
          "title": "MACVLAN"
        },
        "MACVTAP": {
          "type": "string",
          "title": "MACVTAP"
        },
        "Tunnel": {
          "type": "string",
          "title": "Tunnel"
        },
        "VLAN": {
          "allOf": [
            {
              "$ref": "#/definitions/vlan_id"
            }
          ],
          "minimum": 1,
          "description": "The VLAN ID allowed on the port. This can be either a single ID or a range M-N. This setting can be specified multiple times. If an empty string is assigned, then the all previous assignments are cleared.",
          "title": "VLAN"
        },
        "VXLAN": {
          "type": "string",
          "title": "VXLAN"
        },
        "Xfrm": {
          "type": "string",
          "title": "Xfrm"
        },
        "DHCP": {
          "type": "string",
          "enum": [
            "no",
            "yes",
            "ipv4",
            "ipv6"
          ],
          "default": "no",
          "description": "Enables DHCPv4 and/or DHCPv6 client support. Accepts 'yes', 'no', 'ipv4', or 'ipv6'. Defaults to 'no'. Note that DHCPv6 will by default be triggered by Router Advertisements, if reception is enabled, regardless of this parameter. By explicitly enabling DHCPv6 support here, the DHCPv6 client will be started in the mode specified by the WithoutRA= setting in the [DHCPv6] section, regardless of the presence of routers on the link, or what flags the routers pass. See IPv6AcceptRA=. Furthermore, note that by default the domain name specified through DHCP is not used for name resolution. See option 'UseDomains=' below. See the [DHCPv4] or [DHCPv6] sections below for further configuration options for the DHCP client support.",
          "title": "DHCP",
          "examples": [
            "yes",
            "no",
            "ipv4",
            "ipv6"
          ]
        },
        "DHCPServer": {
          "type": "boolean",
          "default": false,
          "description": "If set to 'yes', DHCPv4 server will be started. Defaults to 'no'. Further settings for the DHCP server may be set in the [DHCPServer] section described below. Even if this is enabled, the DHCP server will not be started automatically and wait for the persistent storage being ready to load/save leases in the storage, unless RelayTarget= or PersistLeases=no are specified in the [DHCPServer] section. It will be started after 'systemd-networkd-persistent-storage.service' is started, which calls networkctl persistent-storage yes. See networkctl1 for more details.",
          "title": "DHCP Server",
          "examples": [
            "yes",
            "no"
          ]
        },
        "LinkLocalAddressing": {
          "oneOf": [
            {
              "type": "boolean"
            },
            {
              "type": "string",
              "enum": [
                "ipv4",
                "ipv6"
              ]
            }
          ],
          "default": "no",
          "description": "Enables link-local address autoconfiguration. Accepts a boolean, 'ipv4', and 'ipv6'. An IPv6 link-local address is configured when 'yes' or 'ipv6'. An IPv4 link-local address is configured when 'yes' or 'ipv4' and when DHCPv4 autoconfiguration has been unsuccessful for some time. (IPv4 link-local address autoconfiguration will usually happen in parallel with repeated attempts to acquire a DHCPv4 lease). Defaults to 'no' when KeepMaster= or Bridge= is set or when the specified MACVLAN=/MACVTAP= has Mode=passthru, or 'ipv6' otherwise.",
          "title": "Link Local Addressing",
          "examples": [
            "yes",
            "no",
            "ipv4",
            "ipv6"
          ]
        },
        "IPv4LLRoute": {
          "type": "boolean",
          "default": false,
          "description": "If set to true, sets up the route needed for non-IPv4LL hosts to communicate with IPv4LL-only hosts. Defaults to false.",
          "title": "I Pv4 LL Route"
        },
        "DefaultRouteOnDevice": {
          "type": "boolean",
          "default": false,
          "description": "If set to true, sets up the IPv4 default route bound to the interface. Defaults to false. This is useful when creating routes on point-to-point interfaces. This is equivalent to e.g. the following, ip route add default dev veth99 or, [Route] Gateway=0.0.0.0 Currently, there are no way to specify e.g., the table for the route configured by this setting. To configure the default route with such an additional property, please use the following instead: [Route] Gateway=0.0.0.0 Table=1234 If you'd like to create an IPv6 default route bound to the interface, please use the following: [Route] Gateway=:: Table=1234",
          "title": "Default Route On Device"
        },
        "LLDP": {
          "oneOf": [
            {
              "type": "boolean"
            },
            {
              "type": "string",
              "enum": [
                "routers-only"
              ]
            }
          ],
          "default": "routers-only",
          "description": "Controls support for Ethernet LLDP packet reception. LLDP is a link-layer protocol commonly implemented on professional routers and bridges which announces which physical port a system is connected to, as well as other related data. Accepts a boolean or the special value 'routers-only'. When true, incoming LLDP packets are accepted and a database of all LLDP neighbors maintained. If 'routers-only' is set only LLDP data of various types of routers is collected and LLDP data about other types of devices ignored (such as stations, telephones and others). If false, LLDP reception is disabled. Defaults to 'routers-only'. Use networkctl1 to query the collected neighbor data. LLDP is only available on Ethernet links. See EmitLLDP= below for enabling LLDP packet emission from the local system.",
          "title": "LLDP"
        },
        "EmitLLDP": {
          "oneOf": [
            {
              "type": "boolean"
            },
            {
              "type": "string",
              "enum": [
                "nearest-bridge",
                "non-tpmr-bridge",
                "customer-bridge"
              ]
            }
          ],
          "default": "false",
          "description": "Controls support for Ethernet LLDP packet emission. Accepts a boolean parameter or the special values 'nearest-bridge', 'non-tpmr-bridge' and 'customer-bridge'. Defaults to false, which turns off LLDP packet emission. If not false, a short LLDP packet with information about the local system is sent out in regular intervals on the link. The LLDP packet will contain information about the local hostname, the local machine ID (as stored in machine-id5) and the local interface name, as well as the pretty hostname of the system (as set in machine-info5). LLDP emission is only available on Ethernet links. Note that this setting passes data suitable for identification of host to the network and should thus not be enabled on untrusted networks, where such identification data should not be made available. Use this option to permit other systems to identify on which interfaces they are connected to this system. The three special values control propagation of the LLDP packets. The 'nearest-bridge' setting permits propagation only to the nearest connected bridge, 'non-tpmr-bridge' permits propagation across Two-Port MAC Relays, but not any other bridges, and 'customer-bridge' permits propagation until a customer bridge is reached. For details about these concepts, see IEEE 802.1AB-2016. Note that configuring this setting to true is equivalent to 'nearest-bridge', the recommended and most restricted level of propagation. See LLDP= above for an option to enable LLDP reception.",
          "title": "Emit LLDP"
        },
        "Address": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ip_prefix"
          },
          "description": "A static IPv4 or IPv6 address and its prefix length, separated by a '/' character. Specify this key more than once to configure several addresses. The format of the address must be as described in inet_pton3. This is a short-hand for an [Address] section only containing an Address key (see below). This option may be specified more than once. If the specified address is '0.0.0.0' (for IPv4) or '::' (for IPv6), a new address range of the requested size is automatically allocated from a system-wide pool of unused ranges. Note that the prefix length must be equal or larger than 8 for IPv4, and 64 for IPv6. The allocated range is checked against all current network interfaces and all known network configuration files to avoid address range conflicts. The default system-wide pool consists of 192.168.0.0/16, 172.16.0.0/12 and 10.0.0.0/8 for IPv4, and fd00::/8 for IPv6. This functionality is useful to manage a large number of dynamically created network interfaces with the same network configuration and automatic address range assignment. If an IPv4 link-local address (169.254.0.0/16) is specified, IPv4 Address Conflict Detection (RFC 5227) is enabled for the address. To assign an IPv4 link-local address without IPv4 Address Conflict Detection, please use [Address] section to configure the address and disable DuplicateAddressDetection=. [Address] Address=169.254.10.1/24 DuplicateAddressDetection=none If an empty string is specified, then the all previous assignments in both [Network] and [Address] sections are cleared.",
          "title": "Address"
        },
        "Gateway": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ip_address"
          },
          "description": "The gateway address, which must be in the format described in inet_pton3. This is a short-hand for a [Route] section only containing a Gateway= key. This option may be specified more than once.",
          "title": "Gateway",
          "examples": [
            "192.168.1.1",
            "fe80::1"
          ]
        },
        "Domains": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "A whitespace-separated list of domains which should be resolved using the DNS servers on this link. Each item in the list should be a domain name, optionally prefixed with a tilde ('~'). The domains with the prefix are called \"routing-only domains\". The domains without the prefix are called \"search domains\" and are first used as search suffixes for extending single-label hostnames (hostnames containing no dots) to become fully qualified domain names (FQDNs). If a single-label hostname is resolved on this interface, each of the specified search domains are appended to it in turn, converting it into a fully qualified domain name, until one of them may be successfully resolved. Both \"search\" and \"routing-only\" domains are used for routing of DNS queries: look-ups for hostnames ending in those domains (hence also single label names, if any \"search domains\" are listed), are routed to the DNS servers configured for this interface. The domain routing logic is particularly useful on multi-homed hosts with DNS servers serving particular private DNS zones on each interface. The \"routing-only\" domain '~.' (the tilde indicating definition of a routing domain, the dot referring to the DNS root domain which is the implied suffix of all valid DNS names) has special effect. It causes all DNS traffic which does not match another configured domain routing entry to be routed to DNS servers specified for this interface. This setting is useful to prefer a certain set of DNS servers if a link on which they are connected is available. This setting is read by systemd-resolved.service8. \"Search domains\" correspond to the domain and search entries in resolv.conf5. Domain name routing has no equivalent in the traditional glibc API, which has no concept of domain name servers limited to a specific link.",
          "title": "Domains",
          "examples": [
            "example.com",
            "~."
          ]
        },
        "DNS": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ip_address"
          },
          "description": "A DNS server address, which must be in the format described in inet_pton3. This option may be specified more than once. Each address can optionally take a port number separated with ':', a network interface name or index separated with '%', and a Server Name Indication (SNI) separated with '#'. When IPv6 address is specified with a port number, then the address must be in the square brackets. That is, the acceptable full formats are '111.222.333.444:9953%ifname#example.com' for IPv4 and '[1111:2222::3333]:9953%ifname#example.com' for IPv6. If an empty string is assigned, then the all previous assignments are cleared. This setting is read by systemd-resolved.service8.",
          "title": "DNS",
          "examples": [
            "8.8.8.8",
            "2001:4860:4860::8888"
          ]
        },
        "DNSDefaultRoute": {
          "type": "boolean",
          "description": "If true, this link's configured DNS servers are used for resolving domain names that do not match any link's configured Domains= setting. If false, this link's configured DNS servers are never used for such domains, and are exclusively used for resolving names that match at least one of the domains configured on this link. If not specified defaults to an automatic mode: queries not matching any link's configured domains will be routed to this link if it has no routing-only domains configured.",
          "title": "DNS Default Route"
        },
        "LLMNR": {
          "type": "boolean",
          "default": true,
          "description": "or 'resolve'. When true, enables Link-Local Multicast Name Resolution on the link. When set to 'resolve', only resolution is enabled, but not host registration and announcement. Defaults to true. This setting is read by systemd-resolved.service8.",
          "title": "LLMNR"
        },
        "MulticastDNS": {
          "oneOf": [
            {
              "type": "boolean"
            },
            {
              "type": "string",
              "enum": [
                "resolve"
              ]
            }
          ],
          "description": "Takes a boolean or 'resolve'. When true, enables Multicast DNS support on the link. When set to 'resolve', only resolution is enabled, but not host or service registration and announcement. Defaults to false. This setting is read by systemd-resolved.service8.",
          "default": "false",
          "title": "Multicast DNS"
        },
        "DNSOverTLS": {
          "oneOf": [
            {
              "type": "boolean"
            },
            {
              "type": "string",
              "enum": [
                "opportunistic"
              ]
            }
          ],
          "description": "Takes a boolean or 'opportunistic'. When true, enables DNS-over-TLS support on the link. When set to 'opportunistic', compatibility with non-DNS-over-TLS servers is increased, by automatically turning off DNS-over-TLS servers in this case. This option defines a per-interface setting for resolved.conf5's global DNSOverTLS= option. Defaults to unset, and the global setting will be used. This setting is read by systemd-resolved.service8.",
          "title": "DNS Over TLS"
        },
        "DNSSEC": {
          "oneOf": [
            {
              "type": "boolean"
            },
            {
              "type": "string",
              "enum": [
                "allow-downgrade"
              ]
            }
          ],
          "description": "Takes a boolean or 'allow-downgrade'. When true, enables DNSSEC DNS validation support on the link. When set to 'allow-downgrade', compatibility with non-DNSSEC capable networks is increased, by automatically turning off DNSSEC in this case. This option defines a per-interface setting for resolved.conf5's global DNSSEC= option. Defaults to unset, and the global setting will be used. This setting is read by systemd-resolved.service8.",
          "title": "DNSSEC"
        },
        "DNSSECNegativeTrustAnchors": {
          "type": "string",
          "description": "A space-separated list of DNSSEC negative trust anchor domains. If specified and DNSSEC is enabled, look-ups done via the interface's DNS server will be subject to the list of negative trust anchors, and not require authentication for the specified domains, or anything below it. Use this to disable DNSSEC authentication for specific private domains, that cannot be proven valid using the Internet DNS hierarchy. Defaults to the empty list. This setting is read by systemd-resolved.service8.",
          "title": "DNSSEC Negative Trust Anchors"
        },
        "NTP": {
          "allOf": [
            {
              "$ref": "#/definitions/ip_address"
            }
          ],
          "description": "An NTP server address (either an IP address, or a hostname). This option may be specified more than once. This setting is read by systemd-timesyncd.service8.",
          "title": "NTP",
          "examples": [
            "pool.ntp.org"
          ]
        },
        "IPMasquerade": {
          "type": "string",
          "enum": [
            "both",
            "ipv4",
            "ipv6",
            "no"
          ],
          "default": "no",
          "description": "Configures IP masquerading for the network interface. If enabled, packets forwarded from the network interface will be appear as coming from the local host. Typically, this should be enabled on the downstream interface of routers. Defaults to 'no'. Note that any positive boolean values such as 'yes' or 'true' are now deprecated. Please use one of the values above. Specifying 'ipv4' or 'both' implies IPv4Forwarding= settings in both.network file for this interface and the global networkd.conf5 unless they are explicitly specified. Similarly for IPv6Forwarding= when 'ipv6' or 'both' is specified. See IPv4Forwarding=/IPv6Forwarding= in the above for the per-link settings, and networkd.conf5 for the global settings.",
          "title": "IP Masquerade"
        },
        "IPv6PrivacyExtensions": {
          "oneOf": [
            {
              "type": "boolean"
            },
            {
              "type": "string",
              "enum": [
                "prefer-public",
                "kernel"
              ]
            }
          ],
          "default": false,
          "description": "Configures use of stateless temporary addresses that change over time (see RFC 4941, Privacy Extensions for Stateless Address Autoconfiguration in IPv6). Takes a boolean or the special values 'prefer-public' and 'kernel'. When true, enables the privacy extensions and prefers temporary addresses over public addresses. When 'prefer-public', enables the privacy extensions, but prefers public addresses over temporary addresses. When false, the privacy extensions remain disabled. When 'kernel', the kernel's default setting will be left in place. When unspecified, the value specified in the same setting in networkd.conf5, which defaults to 'no', will be used.",
          "title": "I Pv6 Privacy Extensions"
        },
        "IPv6AcceptRA": {
          "type": "boolean",
          "default": false,
          "description": "Controls IPv6 Router Advertisement (RA) reception support for the interface. If true, RAs are accepted; if false, RAs are ignored. When RAs are accepted, they may trigger the start of the DHCPv6 client if the relevant flags are set in the RA data, or if no routers are found on the link. Defaults to false for bridge devices, when IPv6Forwarding=, IPv6SendRA=, or KeepMaster= is enabled. Otherwise, enabled by default. Cannot be enabled on devices aggregated in a bond device or when link-local addressing is disabled. Further settings for the IPv6 RA support may be configured in the [IPv6AcceptRA] section, see below. Also see IP Sysctl in the kernel documentation regarding 'accept_ra', but note that systemd's setting of '1' (i.e. true) corresponds to kernel's setting of '2'. Note that kernel's implementation of the IPv6 RA protocol is always disabled, regardless of this setting. If this option is enabled, a userspace implementation of the IPv6 RA protocol is used, and the kernel's own implementation remains disabled, since systemd-networkd needs to know all details supplied in the advertisements, and these are not available from the kernel if the kernel's own implementation is used.",
          "title": "I Pv6 Accept RA",
          "examples": [
            "yes",
            "no"
          ]
        },
        "IPv6AcceptRouterAdvertisements": {
          "type": "boolean",
          "title": "I Pv6 Accept Router Advertisements"
        },
        "IPv6DuplicateAddressDetection": {
          "type": "integer",
          "description": "Configures the amount of IPv6 Duplicate Address Detection (DAD) probes to send. When unset, the kernel's default will be used.",
          "title": "I Pv6 Duplicate Address Detection"
        },
        "IPv6HopLimit": {
          "type": "integer",
          "minimum": 1,
          "maximum": 255,
          "description": "Configures IPv6 Hop Limit. For each router that forwards the packet, the hop limit is decremented by 1. When the hop limit field reaches zero, the packet is discarded. When unset, the kernel's default will be used.",
          "title": "I Pv6 Hop Limit"
        },
        "IPv6ProxyNDP": {
          "type": "boolean",
          "description": "Configures proxy NDP for IPv6. Proxy NDP (Neighbor Discovery Protocol) is a technique for IPv6 to allow routing of addresses to a different destination when peers expect them to be present on a certain physical link. In this case a router answers Neighbour Advertisement messages intended for another machine by offering its own MAC address as destination. Unlike proxy ARP for IPv4, it is not enabled globally, but will only send Neighbour Advertisement messages for addresses in the IPv6 neighbor proxy table, which can also be shown by ip -6 neighbour show proxy. systemd-networkd will control the per-interface `proxy_ndp` switch for each configured interface depending on this option. When unset, the kernel's default will be used.",
          "title": "I Pv6 Proxy NDP"
        },
        "IPv6MTUBytes": {
          "allOf": [
            {
              "$ref": "#/definitions/MTUv6Bytes"
            }
          ],
          "description": "Configures IPv6 maximum transmission unit (MTU). An integer greater than or equal to 1280 bytes. When unset, the kernel's default will be used.",
          "title": "IPv6 MTU (Bytes)"
        },
        "ActiveSlave": {
          "type": "boolean",
          "default": false,
          "description": "Specifies the new active slave. The 'ActiveSlave=' option is only valid for following modes: 'active-backup', 'balance-alb', and 'balance-tlb'. Defaults to false.",
          "title": "Active Slave"
        },
        "PrimarySlave": {
          "type": "boolean",
          "default": false,
          "description": "Specifies which slave is the primary device. The specified device will always be the active slave while it is available. Only when the primary is off-line will alternate devices be used. This is useful when one slave is preferred over another, e.g. when one slave has higher throughput than another. The 'PrimarySlave=' option is only valid for following modes: 'active-backup', 'balance-alb', and 'balance-tlb'. Defaults to false.",
          "title": "Primary Slave"
        },
        "IPv4ProxyARP": {
          "type": "boolean",
          "description": "Configures proxy ARP for IPv4. Proxy ARP is the technique in which one host, usually a router, answers ARP requests intended for another machine. By \"faking\" its identity, the router accepts responsibility for routing packets to the \"real\" destination. See RFC 1027. When unset, the kernel's default will be used.",
          "title": "I Pv4 Proxy ARP"
        },
        "ProxyARP": {
          "type": "boolean",
          "description": "Configures whether proxy ARP to be enabled on this port. When unset, the kernel's default will be used.",
          "title": "Proxy ARP"
        },
        "IPv6ProxyNDPAddress": {
          "allOf": [
            {
              "$ref": "#/definitions/ip_address"
            }
          ],
          "description": "An IPv6 address, for which Neighbour Advertisement messages will be proxied. This option may be specified more than once. systemd-networkd will add the IPv6ProxyNDPAddress= entries to the kernel's IPv6 neighbor proxy table. This setting implies IPv6ProxyNDP=yes but has no effect if IPv6ProxyNDP= has been set to false. When unset, the kernel's default will be used.",
          "title": "I Pv6 Proxy NDP Address"
        },
        "BindCarrier": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "A link name or a list of link names. When set, controls the behavior of the current link. When all links in the list are in an operational down state, the current link is brought down. When at least one link has carrier, the current interface is brought up. This forces ActivationPolicy= to be set to 'bound'.",
          "title": "Bind Carrier"
        },
        "ConfigureWithoutCarrier": {
          "type": "boolean",
          "default": false,
          "description": "Allows systemd-networkd to configure a specific link even if it has no carrier. Defaults to false. If enabled, and the IgnoreCarrierLoss= setting is not explicitly set, then it is enabled as well. With this enabled, to make the interface enter the 'configured' state, which is required to make systemd-networkd-wait-online work properly for the interface, all dynamic address configuration mechanisms like DHCP= and IPv6AcceptRA= (which is enabled by default in most cases) need to be disabled. Also, DuplicateAddressDetection= (which is enabled by default for IPv4 link-local addresses and all IPv6 addresses) needs to be disabled for all static address configurations. Otherwise, without carrier, the interface will be stuck in the 'configuring' state, and systemd-networkd-wait-online for the interface will timeout. Also, it is recommended to set RequiredForOnline=no-carrier to make systemd-networkd-wait-online work for the interface.",
          "title": "Configure Without Carrier"
        },
        "IgnoreCarrierLoss": {
          "oneOf": [
            {
              "type": "boolean"
            },
            {
              "$ref": "#/definitions/timespan"
            }
          ],
          "description": "When true, systemd-networkd retains both the static and dynamic configuration of the interface even if its carrier is lost. When false, systemd-networkd drops both the static and dynamic configuration of the interface. When a timespan is specified, systemd-networkd waits for the specified timespan, and ignores the carrier loss if the link regain its carrier within the timespan. Setting 0 seconds is equivalent to 'no', and 'infinite' is equivalent to 'yes'. Setting a finite timespan may be useful when e.g. in the following cases: A wireless interface connecting to a network which has multiple access points with the same SSID. Enslaving a wireless interface to a bond interface, which may disconnect from the connected access point and causes its carrier to be lost. The driver of the interface resets when the MTU is changed. A wireless interface connecting to a network which has multiple access points with the same SSID. Enslaving a wireless interface to a bond interface, which may disconnect from the connected access point and causes its carrier to be lost. The driver of the interface resets when the MTU is changed. When Bond= is specified to a wireless interface, defaults to 3 seconds. When the DHCPv4 client is enabled and UseMTU= in the [DHCPv4] section enabled, defaults to 5 seconds. Otherwise, defaults to the value specified with ConfigureWithoutCarrier=. When ActivationPolicy= is set to 'always-up', this is forced to 'yes', and ignored any user specified values.",
          "title": "Ignore Carrier Loss"
        },
        "KeepConfiguration": {
          "type": "string",
          "enum": [
            "dynamic",
            "dynamic-on-stop",
            "static"
          ],
          "default": "dynamic-on-stop",
          "description": "When 'static', systemd-networkd will not drop statically configured addresses and routes on starting up process. When 'dynamic-on-stop', the dynamically configurad addresses and routes, such as DHCPv4, DHCPv6, SLAAC, and IPv4 link-local address, will not be dropped when systemd-networkd is being stopped. When 'dynamic', the dynamically configured addresses and routes will never be dropped, and the lifetime of DHCPv4 leases will be ignored. This is contrary to the DHCP specification, but may be the best choice if, e.g., the root filesystem relies on this connection. The setting 'dynamic' implies 'dynamic-on-stop', and 'yes' implies 'dynamic' and 'static'. Defaults to 'dynamic-on-stop' when systemd-networkd is running in initrd, 'yes' when the root filesystem is a network filesystem, and 'no' otherwise.",
          "title": "Keep Configuration"
        },
        "IPv4LL": {
          "type": "string",
          "title": "I Pv4 LL"
        },
        "IPv6Token": {
          "type": "string",
          "title": "I Pv6 Token"
        },
        "IPv6PrefixDelegation": {
          "type": "string",
          "title": "I Pv6 Prefix Delegation"
        }
      },
      "additionalProperties": false,
      "title": "Network"
    },
    "Address": {
      "oneOf": [
        {
          "type": "array",
          "items": {
            "type": "object",
            "description": "[Address] section configuration",
            "properties": {
              "Address": {
                "allOf": [
                  {
                    "$ref": "#/definitions/ip_address"
                  }
                ],
                "description": "As in the [Network] section. This setting is mandatory. Each [Address] section can contain one Address= setting.",
                "_mandatory": true
              },
              "Peer": {
                "allOf": [
                  {
                    "$ref": "#/definitions/ip_address"
                  }
                ],
                "description": "The peer address in a point-to-point connection. Accepts the same format as the Address= setting."
              },
              "Broadcast": {
                "oneOf": [
                  {
                    "$ref": "#/definitions/ipv4_address"
                  },
                  {
                    "type": "boolean"
                  }
                ],
                "description": "Takes an IPv4 address or boolean value. The address must be in the format described in inet_pton3. If set to true, then the IPv4 broadcast address will be derived from the Address= setting. If set to false, then the broadcast address will not be set. Defaults to true, except for wireguard interfaces, where it default to false.",
                "default": "true"
              },
              "Label": {
                "type": "string",
                "minLength": 1,
                "maxLength": 15,
                "description": "Specifies the label for the IPv4 address. The label must be a 7-bit ASCII string with a length of 1...15 characters. Defaults to unset."
              },
              "PreferredLifetime": {
                "type": "string",
                "enum": [
                  "forever",
                  "infinity",
                  "0"
                ],
                "description": "Allows the default \"preferred lifetime\" of the address to be overridden. Only three settings are accepted: 'forever', 'infinity', which is the default and means that the address never expires, and '0', which means that the address is considered immediately \"expired\" and will not be used, unless explicitly requested. A setting of 'PreferredLifetime=0' is useful for addresses which are added to be used only by a specific application, which is then configured to use them explicitly."
              },
              "HomeAddress": {
                "type": "boolean",
                "description": "Designates this address the \"home address\" as defined in RFC 6275. Supported only on IPv6. Defaults to false.",
                "default": "false"
              },
              "ManageTemporaryAddress": {
                "type": "boolean",
                "description": "If true the kernel manage temporary addresses created from this one as template on behalf of Privacy Extensions RFC 3041. For this to become active, the use_tempaddr sysctl setting has to be set to a value greater than zero. The given address needs to have a prefix length of 64. This flag allows using privacy extensions in a manually configured network, just like if stateless auto-configuration was active. Defaults to false.",
                "default": "false"
              },
              "PrefixRoute": {
                "type": "string"
              },
              "AutoJoin": {
                "type": "boolean",
                "default": false,
                "description": "Joining multicast group on ethernet level via ip maddr command would not work if we have an Ethernet switch that does IGMP snooping since the switch would not replicate multicast packets on ports that did not have IGMP reports for the multicast addresses. Linux vxlan interfaces created via ip link add vxlan or systemd-networkd's netdev kind vxlan have the group option that enables them to do the required join. By extending ip address command with option 'autojoin' we can get similar functionality for openvswitch (OVS) vxlan interfaces as well as other tunneling mechanisms that need to receive multicast traffic. Defaults to 'no'."
              },
              "DuplicateAddressDetection": {
                "type": "string",
                "enum": [
                  "both",
                  "ipv4",
                  "ipv6",
                  "none"
                ],
                "default": "ipv4",
                "description": "When 'ipv4', performs IPv4 Address Conflict Detection. See RFC 5227. When 'ipv6', performs IPv6 Duplicate Address Detection. See RFC 4862. Defaults to 'ipv4' for IPv4 link-local addresses (169.254.0.0/16), 'ipv6' for IPv6 addresses, and 'none' otherwise."
              },
              "Scope": {
                "oneOf ": [
                  {
                    "type": "string",
                    "enum": [
                      "global",
                      "link",
                      "host"
                    ]
                  },
                  {
                    "allOf": [
                      {
                        "$ref": "#/definitions/uint8"
                      }
                    ]
                  }
                ],
                "default": "global",
                "description": "The scope of the address, which can be 'global' (valid everywhere on the network, even through a gateway), 'link' (only valid on this device, will not traverse a gateway) or 'host' (only valid within the device itself, e.g. 127.0.0.1) or an integer in the range 0...255. Defaults to 'global'. IPv4 only - IPv6 scope is automatically assigned by the kernel and cannot be set manually."
              }
            },
            "additionalProperties": false
          }
        },
        {
          "type": "object",
          "description": "[Address] section configuration",
          "properties": {
            "Address": {
              "allOf": [
                {
                  "$ref": "#/definitions/ip_address"
                }
              ],
              "description": "As in the [Network] section. This setting is mandatory. Each [Address] section can contain one Address= setting.",
              "_mandatory": true
            },
            "Peer": {
              "allOf": [
                {
                  "$ref": "#/definitions/ip_address"
                }
              ],
              "description": "The peer address in a point-to-point connection. Accepts the same format as the Address= setting."
            },
            "Broadcast": {
              "oneOf": [
                {
                  "$ref": "#/definitions/ipv4_address"
                },
                {
                  "type": "boolean"
                }
              ],
              "description": "Takes an IPv4 address or boolean value. The address must be in the format described in inet_pton3. If set to true, then the IPv4 broadcast address will be derived from the Address= setting. If set to false, then the broadcast address will not be set. Defaults to true, except for wireguard interfaces, where it default to false.",
              "default": "true"
            },
            "Label": {
              "type": "string",
              "description": "Specifies the label for the IPv4 address. The label must be a 7-bit ASCII string with a length of 1...15 characters. Defaults to unset."
            },
            "PreferredLifetime": {
              "type": "string",
              "enum": [
                "forever",
                "infinity",
                "0"
              ],
              "description": "Allows the default \"preferred lifetime\" of the address to be overridden. Only three settings are accepted: 'forever', 'infinity', which is the default and means that the address never expires, and '0', which means that the address is considered immediately \"expired\" and will not be used, unless explicitly requested. A setting of 'PreferredLifetime=0' is useful for addresses which are added to be used only by a specific application, which is then configured to use them explicitly."
            },
            "HomeAddress": {
              "type": "boolean",
              "description": "Takes a boolean. Designates this address the \"home address\" as defined in RFC 6275. Supported only on IPv6. Defaults to false.",
              "default": "false"
            },
            "ManageTemporaryAddress": {
              "type": "boolean",
              "description": "Takes a boolean. If true the kernel manage temporary addresses created from this one as template on behalf of Privacy Extensions RFC 3041. For this to become active, the use_tempaddr sysctl setting has to be set to a value greater than zero. The given address needs to have a prefix length of 64. This flag allows using privacy extensions in a manually configured network, just like if stateless auto-configuration was active. Defaults to false.",
              "default": "false"
            },
            "PrefixRoute": {
              "type": "string"
            },
            "AddPrefixRoute": {
              "type": "boolean",
              "default": true,
              "description": "When true, the prefix route for the address is automatically added. Defaults to true."
            },
            "AutoJoin": {
              "type": "boolean",
              "default": false,
              "description": "Joining multicast group on ethernet level via ip maddr command would not work if we have an Ethernet switch that does IGMP snooping since the switch would not replicate multicast packets on ports that did not have IGMP reports for the multicast addresses. Linux vxlan interfaces created via ip link add vxlan or systemd-networkd's netdev kind vxlan have the group option that enables them to do the required join. By extending ip address command with option 'autojoin' we can get similar functionality for openvswitch (OVS) vxlan interfaces as well as other tunneling mechanisms that need to receive multicast traffic. Defaults to 'no'."
            },
            "DuplicateAddressDetection": {
              "type": "string",
              "enum": [
                "both",
                "ipv4",
                "ipv6",
                "none"
              ],
              "default": "ipv4",
              "description": "When 'ipv4', performs IPv4 Address Conflict Detection. See RFC 5227. When 'ipv6', performs IPv6 Duplicate Address Detection. See RFC 4862. Defaults to 'ipv4' for IPv4 link-local addresses (169.254.0.0/16), 'ipv6' for IPv6 addresses, and 'none' otherwise."
            },
            "Scope": {
              "oneOf": [
                {
                  "type": "string",
                  "enum": [
                    "global",
                    "link",
                    "host"
                  ]
                },
                {
                  "allOf": [
                    {
                      "$ref": "#/definitions/uint8"
                    }
                  ]
                }
              ],
              "default": "global",
              "description": "The scope of the address, which can be 'global' (valid everywhere on the network, even through a gateway), 'link' (only valid on this device, will not traverse a gateway) or 'host' (only valid within the device itself, e.g. 127.0.0.1) or an integer in the range 0...255. Defaults to 'global'. IPv4 only - IPv6 scope is automatically assigned by the kernel and cannot be set manually."
            },
            "RouteMetric": {
              "type": "integer",
              "minimum": 0,
              "maximum": 4294967295,
              "description": "The metric of the prefix route, which is pointing to the subnet of the configured IP address, taking the configured prefix length into account. Takes an unsigned integer in the range 0...4294967295. When unset or set to 0, the kernel's default value is used. This setting will be ignored when AddPrefixRoute= is false."
            },
            "NetLabel": {
              "type": "string",
              "description": "This setting provides a method for integrating static and dynamic network configuration into Linux NetLabel subsystem rules, used by Linux Security Modules (LSMs) for network access control. The label, with suitable LSM rules, can be used to control connectivity of (for example) a service with peers in the local network. At least with SELinux, only the ingress can be controlled but not egress. The benefit of using this setting is that it may be possible to apply interface independent part of NetLabel configuration at very early stage of system boot sequence, at the time when the network interfaces are not available yet, with netlabelctl8, and the per-interface configuration with systemd-networkd once the interfaces appear later. Currently this feature is only implemented for SELinux. The option expects a single NetLabel label. The label must conform to lexical restrictions of LSM labels. When an interface is configured with IP addresses, the addresses and subnetwork masks will be appended to the NetLabel Fallback Peer Labeling rules. They will be removed when the interface is deconfigured. Failures to manage the labels will be ignored. Once labeling is enabled for network traffic, a lot of LSM access control points in Linux networking stack go from dormant to active. Care should be taken to avoid getting into a situation where for example remote connectivity is broken, when the security policy hasn't been updated to consider LSM per-packet access controls and no rules would allow any network traffic. Also note that additional configuration with netlabelctl8 is needed. Example: [Address] NetLabel=system_u:object_r:localnet_peer_t:s0 With the example rules applying for interface 'eth0', when the interface is configured with an IPv4 address of 10.0.0.123/8, systemd-networkd performs the equivalent of netlabelctl operation netlabelctl unlbl add interface eth0 address:10.0.0.0/8 label:system_u:object_r:localnet_peer_t:s0 and the reverse operation when the IPv4 address is deconfigured. The configuration can be used with LSM rules; in case of SELinux to allow a SELinux domain to receive data from objects of SELinux 'peer' class. For example: type localnet_peer_t; allow my_server_t localnet_peer_t:peer recv; The effect of the above configuration and rules (in absence of other rules as may be the case) is to only allow 'my_server_t' (and nothing else) to receive data from local subnet 10.0.0.0/8 of interface 'eth0'."
            },
            "NFTSet": {
              "type": "string",
              "description": "This setting provides a method for integrating network configuration into firewall rules with NFT sets. The benefit of using the setting is that static network configuration (or dynamically obtained network addresses, see similar directives in other sections) can be used in firewall rules with the indirection of NFT set types. For example, access could be granted for hosts in the local subnetwork only. Firewall rules using IP address of an interface are also instantly updated when the network configuration changes, for example via DHCP. This option expects a whitespace separated list of NFT set definitions. Each definition consists of a colon-separated tuple of source type (one of 'address', 'prefix' or 'ifindex'), NFT address family (one of 'arp', 'bridge', 'inet', 'ip', 'ip6', or 'netdev'), table name and set name. The names of tables and sets must conform to lexical restrictions of NFT table names. The type of the element used in the NFT filter must match the type implied by the directive ('address', 'prefix' or 'ifindex') and address type (IPv4 or IPv6) as shown in the table below. When an interface is configured with IP addresses, the addresses, subnetwork masks or interface index will be appended to the NFT sets. The information will be removed when the interface is deconfigured. systemd-networkd only inserts elements to (or removes from) the sets, so the related NFT rules, tables and sets must be prepared elsewhere in advance. Failures to manage the sets will be ignored. Example: [Address] NFTSet=prefix:netdev:filter:eth_ipv4_prefix Corresponding NFT rules: table netdev filter { set eth_ipv4_prefix { type ipv4_addr flags interval } chain eth_ingress { type filter hook ingress device \"eth0\" priority filter; policy drop; ip daddr != @eth_ipv4_prefix drop accept } }"
            }
          },
          "additionalProperties": false
        }
      ],
      "description": "[Address] configuration (Can be repeated)",
      "title": "Address"
    },
    "IPv6AddressLabel": {
      "oneOf": [
        {
          "type": "array",
          "items": {
            "type": "object",
            "description": "[IPv6AddressLabel] section configuration",
            "properties": {
              "Prefix": {
                "allOf": [
                  {
                    "$ref": "#/definitions/ipv6_prefix"
                  }
                ],
                "description": "Takes an IPv6 address with a prefix length, separated by a slash '/' character. This setting is mandatory.",
                "_mandatory": true
              },
              "Label": {
                "allOf": [
                  {
                    "$ref": "#/definitions/uint32"
                  }
                ],
                "description": "The label for the prefix. Takes an unsigned integer in the range 0...4294967294 (0xfffffffe). 4294967295 (0xffffffff) is reserved. This setting is mandatory."
              }
            },
            "additionalProperties": false,
            "required": [
              "Label"
            ]
          }
        },
        {
          "type": "object",
          "description": "[IPv6AddressLabel] section configuration",
          "properties": {
            "Prefix": {
              "allOf": [
                {
                  "$ref": "#/definitions/ipv6_prefix"
                }
              ],
              "description": "Takes an IPv6 address with a prefix length, separated by a slash '/' character. This setting is mandatory.",
              "_mandatory": true
            },
            "Label": {
              "allOf": [
                {
                  "$ref": "#/definitions/uint32"
                }
              ],
              "description": "The label for the prefix. Takes an unsigned integer in the range 0...4294967294 (0xfffffffe). 4294967295 (0xffffffff) is reserved. This setting is mandatory."
            }
          },
          "additionalProperties": false,
          "required": [
            "Label"
          ]
        }
      ],
      "description": "[IPv6AddressLabel] configuration (Can be repeated)",
      "title": "I Pv6 Address Label"
    },
    "Neighbor": {
      "oneOf": [
        {
          "type": "array",
          "items": {
            "type": "object",
            "description": "[Neighbor] section configuration",
            "properties": {
              "Address": {
                "allOf": [
                  {
                    "$ref": "#/definitions/ip_address"
                  }
                ],
                "description": "The IP address of the neighbor."
              },
              "LinkLayerAddress": {
                "oneOf": [
                  {
                    "$ref": "#/definitions/ip_address"
                  },
                  {
                    "$ref": "#/definitions/mac_address"
                  }
                ],
                "description": "The link layer address (MAC address or IP address) of the neighbor."
              },
              "MACAddress": {
                "allOf": [
                  {
                    "$ref": "#/definitions/mac_address"
                  }
                ],
                "description": "The hardware address to set for the device."
              }
            },
            "additionalProperties": false
          }
        },
        {
          "type": "object",
          "description": "[Neighbor] section configuration",
          "properties": {
            "Address": {
              "allOf": [
                {
                  "$ref": "#/definitions/ip_address"
                }
              ],
              "description": "The IP address of the neighbor."
            },
            "LinkLayerAddress": {
              "oneOf": [
                {
                  "$ref": "#/definitions/ip_address"
                },
                {
                  "$ref": "#/definitions/mac_address"
                }
              ],
              "description": "The link layer address (MAC address or IP address) of the neighbor."
            },
            "MACAddress": {
              "allOf": [
                {
                  "$ref": "#/definitions/mac_address"
                }
              ],
              "description": "The hardware address to set for the device."
            }
          },
          "additionalProperties": false
        }
      ],
      "description": "[Neighbor] configuration (Can be repeated)",
      "title": "Neighbor"
    },
    "RoutingPolicyRule": {
      "oneOf": [
        {
          "type": "array",
          "items": {
            "type": "object",
            "description": "[RoutingPolicyRule] section configuration",
            "properties": {
              "TypeOfService": {
                "type": "string",
                "description": "This specifies the Type of Service (ToS) field of packets to match; it takes an unsigned integer in the range 0...255. The field can be used to specify precedence (the first 3 bits) and ToS (the next 3 bits). The field can be also used to specify Differentiated Services Code Point (DSCP) (the first 6 bits) and Explicit Congestion Notification (ECN) (the last 2 bits). See Type of Service and Differentiated services for more details."
              },
              "Priority": {
                "type": "string",
                "description": "Specifies the priority of this rule. Priority= is an integer in the range 0...4294967295. Higher number means lower priority, and rules get processed in order of increasing number. Defaults to unset, and the kernel will pick a value dynamically."
              },
              "Table": {
                "oneOf": [
                  {
                    "type": "string"
                  },
                  {
                    "type": "integer",
                    "minimum": 1,
                    "maximum": 4294967295
                  }
                ],
                "default": "main",
                "description": "Specifies the routing table identifier to look up if the rule selector matches. conf5, or a number between 1 and 4294967295. Defaults to 'main'. Ignored if L3MasterDevice= is true."
              },
              "FirewallMark": {
                "oneOf": [
                  {
                    "type": "string"
                  },
                  {
                    "type": "integer",
                    "minimum": 1,
                    "maximum": 4294967295
                  }
                ],
                "description": "Specifies the iptables firewall mark value to match (a number in the range 1...4294967295). Optionally, the firewall mask (also a number between 1...4294967295) can be suffixed with a slash ('/'), e.g., '7/255'."
              },
              "From": {
                "oneOf": [
                  {
                    "$ref": "#/definitions/ip_address"
                  },
                  {
                    "$ref": "#/definitions/ip_prefix"
                  }
                ],
                "description": "Specifies the source address prefix to match. Possibly followed by a slash and the prefix length."
              },
              "To": {
                "oneOf": [
                  {
                    "$ref": "#/definitions/ip_address"
                  },
                  {
                    "$ref": "#/definitions/ip_prefix"
                  }
                ],
                "description": "Specifies the destination address prefix to match. Possibly followed by a slash and the prefix length."
              },
              "IncomingInterface": {
                "type": "string",
                "description": "Specifies incoming device to match. If the interface is loopback, the rule only matches packets originating from this host."
              },
              "OutgoingInterface": {
                "type": "string",
                "description": "Specifies the outgoing device to match. The outgoing interface is only available for packets originating from local sockets that are bound to a device."
              },
              "IPProtocol": {
                "type": "string",
                "description": "Specifies the IP protocol to match in forwarding information base (FIB) rules. Takes IP protocol name such as 'tcp', 'udp' or 'sctp', or IP protocol number such as '6' for 'tcp' or '17' for 'udp'. Defaults to unset."
              },
              "SourcePort": {
                "oneOf": [
                  {
                    "type": "string",
                    "regex": "^[0-9]+?-[0-9]+$"
                  },
                  {
                    "type": "integer",
                    "minimum": 1,
                    "maximum": 65535
                  }
                ],
                "description": "Specifies the source IP port or IP port range match in forwarding information base (FIB) rules. A port range is specified by the lower and upper port separated by a dash. Defaults to unset."
              },
              "DestinationPort": {
                "oneOf": [
                  {
                    "type": "string",
                    "regex": "^[0-9]+?-[0-9]+$"
                  },
                  {
                    "type": "integer",
                    "minimum": 1,
                    "maximum": 65535
                  }
                ],
                "description": "Specifies the destination IP port or IP port range match in forwarding information base (FIB) rules. A port range is specified by the lower and upper port separated by a dash. Defaults to unset."
              },
              "InvertRule": {
                "type": "string",
                "default": "false",
                "description": "A boolean. Specifies whether the rule is to be inverted. Defaults to false."
              },
              "Family": {
                "type": "string",
                "enum": [
                  "ipv4",
                  "ipv6",
                  "both"
                ],
                "default": "ipv4",
                "description": "Takes a special value 'ipv4', 'ipv6', or 'both'. By default, the address family is determined by the address specified in To= or From=. If neither To= nor From= are specified, then defaults to 'ipv4'."
              }
            },
            "additionalProperties": false,
            "required": [
              "GoTo",
              "Type"
            ]
          }
        },
        {
          "type": "object",
          "description": "[RoutingPolicyRule] section configuration",
          "properties": {
            "TypeOfService": {
              "allOf": [
                {
                  "$ref": "#/definitions/uint8"
                }
              ],
              "description": "This specifies the Type of Service (ToS) field of packets to match; it takes an unsigned integer in the range 0...255. The field can be used to specify precedence (the first 3 bits) and ToS (the next 3 bits). The field can be also used to specify Differentiated Services Code Point (DSCP) (the first 6 bits) and Explicit Congestion Notification (ECN) (the last 2 bits). See Type of Service and Differentiated services for more details."
            },
            "Priority": {
              "type": "integer",
              "minimum": 0,
              "maximum": 4294967295,
              "description": "Specifies the priority of this rule. Priority= is an integer in the range 0...4294967295. Higher number means lower priority, and rules get processed in order of increasing number. Defaults to unset, and the kernel will pick a value dynamically."
            },
            "GoTo": {
              "type": "integer",
              "minimum": 1,
              "maximum": 4294967295,
              "description": "Specifies the target priority used by 'goto' type of rule. This must be larger than the priority of this rule specified in Priority=. When specified, Type=goto is implied. This is mandatory when Type=goto."
            },
            "Table": {
              "oneOf": [
                {
                  "type": "string",
                  "enum": [
                    "default",
                    "local",
                    "main"
                  ]
                },
                {
                  "type": "integer",
                  "minimum": 1,
                  "maximum": 4294967295
                }
              ],
              "default": "main",
              "description": "Specifies the routing table identifier to look up if the rule selector matches. conf5, or a number between 1 and 4294967295. Defaults to 'main'. Ignored if L3MasterDevice= is true."
            },
            "FirewallMark": {
              "oneOf": [
                {
                  "type": "string"
                },
                {
                  "type": "integer",
                  "minimum": 1,
                  "maximum": 4294967295
                }
              ],
              "description": "Specifies the iptables firewall mark value to match (a number in the range 1...4294967295). Optionally, the firewall mask (also a number between 1...4294967295) can be suffixed with a slash ('/'), e.g., '7/255'."
            },
            "From": {
              "oneOf": [
                {
                  "$ref": "#/definitions/ip_address"
                },
                {
                  "$ref": "#/definitions/ip_prefix"
                }
              ],
              "description": "Specifies the source address prefix to match. Possibly followed by a slash and the prefix length."
            },
            "To": {
              "oneOf": [
                {
                  "$ref": "#/definitions/ip_address"
                },
                {
                  "$ref": "#/definitions/ip_prefix"
                }
              ],
              "description": "Specifies the destination address prefix to match. Possibly followed by a slash and the prefix length."
            },
            "IncomingInterface": {
              "type": "string",
              "description": "Specifies incoming device to match. If the interface is loopback, the rule only matches packets originating from this host."
            },
            "OutgoingInterface": {
              "type": "string",
              "description": "Specifies the outgoing device to match. The outgoing interface is only available for packets originating from local sockets that are bound to a device."
            },
            "IPProtocol": {
              "type": "string",
              "description": "Specifies the IP protocol to match in forwarding information base (FIB) rules. Takes IP protocol name such as 'tcp', 'udp' or 'sctp', or IP protocol number such as '6' for 'tcp' or '17' for 'udp'. Defaults to unset."
            },
            "SourcePort": {
              "type": "string",
              "description": "Specifies the source IP port or IP port range match in forwarding information base (FIB) rules. A port range is specified by the lower and upper port separated by a dash. Defaults to unset."
            },
            "DestinationPort": {
              "type": "string",
              "description": "Specifies the destination IP port or IP port range match in forwarding information base (FIB) rules. A port range is specified by the lower and upper port separated by a dash. Defaults to unset."
            },
            "InvertRule": {
              "type": "string",
              "default": "false",
              "description": "A boolean. Specifies whether the rule is to be inverted. Defaults to false."
            },
            "L3MasterDevice": {
              "type": "boolean",
              "default": false,
              "description": "Specifies whether the rule is to direct lookups to the tables associated with level 3 master devices (also known as Virtual Routing and Forwarding or VRF devices). For further details see Virtual Routing and Forwarding (VRF). Defaults to false."
            },
            "Family": {
              "type": "string",
              "enum": [
                "ipv4",
                "ipv6",
                "both"
              ],
              "default": "ipv4",
              "description": "Takes a special value 'ipv4', 'ipv6', or 'both'. By default, the address family is determined by the address specified in To= or From=. If neither To= nor From= are specified, then defaults to 'ipv4'."
            },
            "User": {
              "type": "string",
              "description": "Takes a username, a user ID, or a range of user IDs separated by a dash. Defaults to unset."
            },
            "SuppressInterfaceGroup": {
              "type": "integer",
              "minimum": 0,
              "maximum": 2147483647,
              "description": "and rejects routing decisions that have an interface with the same group id. It has the same meaning as 'suppress_ifgroup' in ip rule. Defaults to unset."
            },
            "SuppressPrefixLength": {
              "type": "string",
              "description": "Takes a number N in the range 0...128 and rejects routing decisions that have a prefix length of N or less. Defaults to unset."
            },
            "Type": {
              "type": "string",
              "enum": [
                "blackhole",
                "goto",
                "nop",
                "prohibit",
                "table",
                "unreachable"
              ],
              "default": "table",
              "description": "Specifies Routing Policy Database (RPDB) rule type. When 'goto', the target priority must be specified in GoTo=. Defaults to 'table'."
            }
          },
          "additionalProperties": false,
          "required": [
            "GoTo",
            "Type"
          ]
        }
      ],
      "description": "[RoutingPolicyRule] configuration (Can be repeated)",
      "title": "Routing Policy Rule"
    },
    "Route": {
      "oneOf": [
        {
          "type": "array",
          "items": {
            "type": "object",
            "description": "[Route] section configuration",
            "properties": {
              "Gateway": {
                "oneOf": [
                  {
                    "$ref": "#/definitions/ip_address"
                  },
                  {
                    "type": "string",
                    "enum": [
                      "_dhcp4",
                      "_ipv6ra"
                    ]
                  }
                ],
                "description": "Takes the gateway address or the special values '_dhcp4' and '_ipv6ra'. If '_dhcp4' or '_ipv6ra' is set, then the gateway address provided by DHCPv4 or IPv6 RA is used."
              },
              "Destination": {
                "allOf": [
                  {
                    "$ref": "#/definitions/ip_prefix"
                  }
                ],
                "description": "The destination prefix of the route. Possibly followed by a slash and the prefix length. If omitted, a full-length host route is assumed."
              },
              "Source": {
                "allOf": [
                  {
                    "$ref": "#/definitions/ip_prefix"
                  }
                ],
                "description": "The source prefix of the route. Possibly followed by a slash and the prefix length. If omitted, a full-length host route is assumed."
              },
              "Metric": {
                "type": "integer",
                "minimum": 0,
                "maximum": 4294967295,
                "description": "The metric of the route. Takes an unsigned integer in the range 0...4294967295. Defaults to unset, and the kernel's default will be used."
              },
              "Scope": {
                "type": "string",
                "enum": [
                  "global",
                  "site",
                  "link",
                  "host",
                  "nowhere"
                ],
                "description": "The scope of the IPv4 route, which can be 'global', 'site', 'link', 'host', or 'nowhere': 'global' means the route can reach hosts more than one hop away. 'site' means an interior route in the local autonomous system. 'link' means the route can only reach hosts on the local network (one hop away). 'host' means the route will not leave the local machine (used for internal addresses like 127.0.0.1). 'nowhere' means the destination doesn't exist. For IPv4 route, defaults to 'host' if Type= is 'local' or 'nat', and 'link' if Type= is 'broadcast', 'multicast', 'anycast', or 'unicast'. In other cases, defaults to 'global'. The value is not used for IPv6."
              },
              "PreferredSource": {
                "allOf": [
                  {
                    "$ref": "#/definitions/ip_address"
                  }
                ],
                "description": "The preferred source address of the route. The address must be in the format described in inet_pton3."
              },
              "Table": {
                "oneOf": [
                  {
                    "type": "string",
                    "enum": [
                      "default",
                      "local",
                      "main"
                    ]
                  },
                  {
                    "type": "integer",
                    "minimum": 1,
                    "maximum": 4294967295
                  }
                ],
                "default": "main",
                "description": "The table identifier for the route. conf5, or a number between 1 and 4294967295. The table can be retrieved using ip route show table num. If unset and Type= is 'local', 'broadcast', 'anycast', or 'nat', then 'local' is used. In other cases, defaults to 'main'."
              },
              "GatewayOnLink": {
                "type": "boolean",
                "default": false,
                "description": "If set to true, the kernel does not have to check if the gateway is reachable directly by the current machine (i.e., attached to the local network), so that we can insert the route in the kernel table without it being complained about. Defaults to 'no'."
              },
              "GatewayOnlink": {
                "type": "string"
              },
              "IPv6Preference": {
                "type": "string",
                "enum": [
                  "low",
                  "medium",
                  "high"
                ],
                "description": "Specifies the route preference as defined in RFC 4191 for Router Discovery messages. Which can be one of 'low' the route has a lowest priority, 'medium' the route has a default priority or 'high' the route has a highest priority."
              },
              "Protocol": {
                "oneOf": [
                  {
                    "allOf": [
                      {
                        "$ref": "#/definitions/uint8"
                      }
                    ]
                  },
                  {
                    "type": "string",
                    "enum": [
                      "kernel",
                      "boot",
                      "static",
                      "ra",
                      "dhcp"
                    ]
                  }
                ],
                "description": "The protocol identifier for the route. or the special values 'kernel', 'boot', 'static', 'ra' and 'dhcp'. Defaults to 'static'."
              },
              "Type": {
                "type": "string",
                "enum": [
                  "anycast",
                  "blackhole",
                  "broadcast",
                  "local",
                  "multicast",
                  "nat",
                  "prohibit",
                  "throw",
                  "unicast",
                  "unreachable",
                  "xresolve"
                ],
                "default": "unicast",
                "description": "Specifies the type for the route. If 'unicast', a regular route is defined, i.e. a route indicating the path to take to a destination network address. If 'blackhole', packets to the defined route are discarded silently. If 'unreachable', packets to the defined route are discarded and the ICMP message \"Host Unreachable\" is generated. If 'prohibit', packets to the defined route are discarded and the ICMP message \"Communication Administratively Prohibited\" is generated. If 'throw', route lookup in the current routing table will fail and the route selection process will return to Routing Policy Database (RPDB). Defaults to 'unicast'."
              },
              "MTUBytes": {
                "allOf": [
                  {
                    "$ref": "#/definitions/MTUBytes"
                  }
                ],
                "description": "The maximum transmission unit in bytes to set for the route. The usual suffixes K, M, G, are supported and are understood to the base of 1024."
              },
              "InitialCongestionWindow": {
                "type": "integer",
                "minimum": 1,
                "maximum": 1023,
                "description": "The TCP initial congestion window is used during the start of a TCP connection. During the start of a TCP session, when a client requests a resource, the server's initial congestion window determines how many packets will be sent during the initial burst of data without waiting for acknowledgement. Note that 100 is considered an extremely large value for this option. When unset, the kernel's default (typically 10) will be used."
              },
              "InitialAdvertisedReceiveWindow": {
                "allOf": [
                  {
                    "$ref": "#/definitions/bytes"
                  },
                  {
                    "type": "integer",
                    "minimum": 1,
                    "maximum": 1023
                  }
                ],
                "description": "The TCP initial advertised receive window is the amount of receive data (in bytes) that can initially be buffered at one time on a connection. The sending host can send only that amount of data before waiting for an acknowledgment and window update from the receiving host. Note that 100 is considered an extremely large value for this option. When unset, the kernel's default will be used."
              },
              "QuickAck": {
                "type": "boolean",
                "description": "When true, the TCP quick ACK mode for the route is enabled. When unset, the kernel's default will be used."
              },
              "FastOpenNoCookie": {
                "type": "boolean",
                "description": "When true enables TCP fastopen without a cookie on a per-route basis. When unset, the kernel's default will be used."
              },
              "TTLPropagate": {
                "type": "string"
              },
              "IPServiceType": {
                "type": "string",
                "default": "CS6",
                "description": "Takes string; 'CS6' or 'CS4'. Used to set IP service type to CS6 (network control) or CS4 (Realtime). Defaults to CS6."
              }
            },
            "additionalProperties": false
          }
        },
        {
          "type": "object",
          "description": "[Route] section configuration",
          "properties": {
            "Gateway": {
              "oneOf": [
                {
                  "$ref": "#/definitions/ip_address"
                },
                {
                  "type": "string",
                  "enum": [
                    "_dhcp4",
                    "_ipv6ra"
                  ]
                }
              ],
              "description": "Takes the gateway address or the special values '_dhcp4' and '_ipv6ra'. If '_dhcp4' or '_ipv6ra' is set, then the gateway address provided by DHCPv4 or IPv6 RA is used."
            },
            "Destination": {
              "oneOf": [
                {
                  "$ref": "#/definitions/ip_prefix"
                },
                {
                  "$ref": "#/definitions/ip_address"
                }
              ],
              "description": "The destination prefix of the route. Possibly followed by a slash and the prefix length. If omitted, a full-length host route is assumed."
            },
            "Source": {
              "oneOf": [
                {
                  "$ref": "#/definitions/ip_prefix"
                },
                {
                  "$ref": "#/definitions/ip_address"
                }
              ],
              "description": "The source prefix of the route. Possibly followed by a slash and the prefix length. If omitted, a full-length host route is assumed."
            },
            "Metric": {
              "type": "integer",
              "minimum": 0,
              "maximum": 4294967295,
              "description": "The metric of the route. Takes an unsigned integer in the range 0...4294967295. Defaults to unset, and the kernel's default will be used."
            },
            "Scope": {
              "type": "string",
              "enum": [
                "global",
                "site",
                "link",
                "host",
                "nowhere"
              ],
              "default": "host",
              "description": "The scope of the IPv4 route, which can be 'global', 'site', 'link', 'host', or 'nowhere': 'global' means the route can reach hosts more than one hop away. 'site' means an interior route in the local autonomous system. 'link' means the route can only reach hosts on the local network (one hop away). 'host' means the route will not leave the local machine (used for internal addresses like 127.0.0.1). 'nowhere' means the destination doesn't exist. For IPv4 route, defaults to 'host' if Type= is 'local' or 'nat', and 'link' if Type= is 'broadcast', 'multicast', 'anycast', or 'unicast'. In other cases, defaults to 'global'. The value is not used for IPv6."
            },
            "PreferredSource": {
              "allOf": [
                {
                  "$ref": "#/definitions/ip_address"
                }
              ],
              "description": "The preferred source address of the route. The address must be in the format described in inet_pton3."
            },
            "Table": {
              "oneOf": [
                {
                  "type": "string",
                  "enum": [
                    "default",
                    "local",
                    "main"
                  ]
                },
                {
                  "type": "integer",
                  "minimum": 1,
                  "maximum": 4294967295
                }
              ],
              "default": "main",
              "description": "The table identifier for the route. conf5, or a number between 1 and 4294967295. The table can be retrieved using ip route show table num. If unset and Type= is 'local', 'broadcast', 'anycast', or 'nat', then 'local' is used. In other cases, defaults to 'main'."
            },
            "GatewayOnLink": {
              "type": "boolean",
              "default": false,
              "description": "If set to true, the kernel does not have to check if the gateway is reachable directly by the current machine (i.e., attached to the local network), so that we can insert the route in the kernel table without it being complained about. Defaults to 'no'."
            },
            "IPv6Preference": {
              "type": "string",
              "enum": [
                "low",
                "medium",
                "high"
              ],
              "description": "Specifies the route preference as defined in RFC 4191 for Router Discovery messages. Which can be one of 'low' the route has a lowest priority, 'medium' the route has a default priority or 'high' the route has a highest priority."
            },
            "Protocol": {
              "oneOf": [
                {
                  "allOf": [
                    {
                      "$ref": "#/definitions/uint8"
                    }
                  ]
                },
                {
                  "type": "string",
                  "enum": [
                    "kernel",
                    "boot",
                    "static",
                    "ra",
                    "dhcp"
                  ]
                }
              ],
              "description": "The protocol identifier for the route. or the special values 'kernel', 'boot', 'static', 'ra' and 'dhcp'. Defaults to 'static'."
            },
            "Type": {
              "type": "string",
              "enum": [
                "anycast",
                "blackhole",
                "broadcast",
                "local",
                "multicast",
                "nat",
                "prohibit",
                "throw",
                "unicast",
                "unreachable",
                "xresolve"
              ],
              "default": "unicast",
              "description": "Specifies the type for the route. If 'unicast', a regular route is defined, i.e. a route indicating the path to take to a destination network address. If 'blackhole', packets to the defined route are discarded silently. If 'unreachable', packets to the defined route are discarded and the ICMP message \"Host Unreachable\" is generated. If 'prohibit', packets to the defined route are discarded and the ICMP message \"Communication Administratively Prohibited\" is generated. If 'throw', route lookup in the current routing table will fail and the route selection process will return to Routing Policy Database (RPDB). Defaults to 'unicast'."
            },
            "MultiPathRoute": {
              "type": "string",
              "description": "Configures multipath route. Multipath routing is the technique of using multiple alternative paths through a network. Takes gateway address. Optionally, takes a network interface name or index separated with '@', and a weight in 1..256 for this multipath route separated with whitespace. This setting can be specified multiple times. If an empty string is assigned, then the all previous assignments are cleared."
            },
            "NextHop": {
              "type": "integer",
              "minimum": 1,
              "maximum": 4294967295,
              "description": "Specifies the nexthop id. Takes an unsigned integer in the range 1...4294967295. If set, the corresponding [NextHop] section must be configured. Defaults to unset."
            },
            "MTUBytes": {
              "allOf": [
                {
                  "$ref": "#/definitions/MTUBytes"
                }
              ],
              "description": "The maximum transmission unit in bytes to set for the route. The usual suffixes K, M, G, are supported and are understood to the base of 1024."
            },
            "TCPAdvertisedMaximumSegmentSize": {
              "allOf": [
                {
                  "$ref": "#/definitions/bytes"
                }
              ],
              "description": "Specifies the Path MSS (in bytes) hints given on TCP layer. The usual suffixes K, M, G, are supported and are understood to the base of 1024. An unsigned integer in the range 1...4294967294. When unset, the kernel's default will be used."
            },
            "HopLimit": {
              "type": "integer",
              "minimum": 1,
              "maximum": 255,
              "description": "Configures per route hop limit. See also IPv6HopLimit=."
            },
            "InitialCongestionWindow": {
              "type": "integer",
              "minimum": 1,
              "maximum": 1023,
              "description": "The TCP initial congestion window is used during the start of a TCP connection. During the start of a TCP session, when a client requests a resource, the server's initial congestion window determines how many packets will be sent during the initial burst of data without waiting for acknowledgement. Note that 100 is considered an extremely large value for this option. When unset, the kernel's default (typically 10) will be used."
            },
            "TCPRetransmissionTimeoutSec": {
              "allOf": [
                {
                  "$ref": "#/definitions/seconds"
                }
              ],
              "description": "Specifies the TCP Retransmission Timeout (RTO) for the route. Takes time values in seconds. This value specifies the timeout of an alive TCP connection, when retransmissions remain unacknowledged. When unset, the kernel's default will be used."
            },
            "InitialAdvertisedReceiveWindow": {
              "allOf": [
                {
                  "$ref": "#/definitions/bytes"
                }
              ],
              "description": "The TCP initial advertised receive window is the amount of receive data (in bytes) that can initially be buffered at one time on a connection. The sending host can send only that amount of data before waiting for an acknowledgment and window update from the receiving host. Note that 100 is considered an extremely large value for this option. When unset, the kernel's default will be used."
            },
            "QuickAck": {
              "type": "boolean",
              "description": "When true, the TCP quick ACK mode for the route is enabled. When unset, the kernel's default will be used."
            },
            "TCPCongestionControlAlgorithm": {
              "type": "string",
              "description": "Specifies the TCP congestion control algorithm for the route. Takes a name of the algorithm, e.g. 'bbr', 'dctcp', or 'vegas'. When unset, the kernel's default will be used."
            },
            "FastOpenNoCookie": {
              "type": "boolean",
              "description": "When true enables TCP fastopen without a cookie on a per-route basis. When unset, the kernel's default will be used."
            },
            "TTLPropagate": {
              "type": "string"
            }
          },
          "additionalProperties": false
        }
      ],
      "description": "[Route] configuration (Can be repeated)",
      "title": "Route"
    },
    "NextHop": {
      "oneOf": [
        {
          "type": "array",
          "items": {
            "type": "object",
            "description": "[NextHop] section configuration",
            "properties": {
              "Id": {
                "type": "integer",
                "minimum": 1,
                "maximum": 4294967295,
                "description": "The id of the next hop. This is mandatory if ManageForeignNextHops=no is specified in networkd.conf5. Otherwise, if unspecified, an unused ID will be automatically picked."
              },
              "Gateway": {
                "allOf": [
                  {
                    "$ref": "#/definitions/ip_address"
                  }
                ],
                "description": "As in the [Network] section."
              }
            },
            "additionalProperties": false,
            "required": [
              "Id"
            ]
          }
        },
        {
          "type": "object",
          "description": "[NextHop] section configuration",
          "properties": {
            "Id": {
              "type": "integer",
              "minimum": 1,
              "maximum": 4294967295,
              "description": "The id of the next hop. This is mandatory if ManageForeignNextHops=no is specified in networkd.conf5. Otherwise, if unspecified, an unused ID will be automatically picked."
            },
            "Gateway": {
              "allOf": [
                {
                  "$ref": "#/definitions/ip_address"
                }
              ],
              "description": "As in the [Network] section."
            },
            "Family": {
              "type": "string",
              "enum": [
                "ipv4",
                "ipv6"
              ],
              "default": "ipv4",
              "description": "By default, the family is determined by the address specified in Gateway=. If Gateway= is not specified, then defaults to 'ipv4'."
            },
            "OnLink": {
              "type": "boolean",
              "default": false,
              "description": "If set to true, the kernel does not have to check if the gateway is reachable directly by the current machine (i.e., attached to the local network), so that we can insert the nexthop in the kernel table without it being complained about. Defaults to 'no'."
            },
            "Blackhole": {
              "type": "boolean",
              "default": false,
              "description": "If enabled, packets to the corresponding routes are discarded silently, and Gateway= cannot be specified. Defaults to 'no'."
            },
            "Group": {
              "type": "string",
              "description": "Takes a whitespace separated list of nexthop IDs. Optionally, each nexthop ID can take a weight after a colon ('id:weight'). The weight must be in the range 1...255. If the weight is not specified, then it is assumed that the weight is 1. This setting cannot be specified with Gateway=, Family=, Blackhole=. This setting can be specified multiple times. If an empty string is assigned, then the all previous assignments are cleared. Defaults to unset."
            }
          },
          "additionalProperties": false,
          "required": [
            "Id"
          ]
        }
      ],
      "description": "[NextHop] configuration (Can be repeated)",
      "title": "Next Hop"
    },
    "DHCPv4": {
      "oneOf": [
        {
          "type": "array",
          "items": {
            "type": "object",
            "description": "[DHCPv4] section configuration",
            "properties": {
              "ClientIdentifier": {
                "type": "string",
                "enum": [
                  "duid",
                  "mac"
                ],
                "default": "duid",
                "description": "The DHCPv4 client identifier to use. If set to 'mac', the MAC address of the link is used. If set to 'duid', an RFC4361-compliant Client ID, which is the combination of IAID and DUID, is used. IAID can be configured by IAID=. DUID can be configured by DUIDType= and DUIDRawData=. Defaults to 'duid'."
              },
              "UseDNS": {
                "type": "boolean",
                "description": "When true (the default), the DNS servers received from the DHCP server will be used. This corresponds to the 'nameserver' option in resolv.conf5."
              },
              "RoutesToDNS": {
                "type": "boolean",
                "default": true,
                "description": "When true, the routes to the DNS servers received from the DHCP server will be configured. When UseDNS= is disabled, this setting is ignored. Defaults to true."
              },
              "UseNTP": {
                "type": "boolean",
                "description": "When true (the default), the NTP servers received from the DHCP server will be used by 'systemd-timesyncd.service'."
              },
              "UseSIP": {
                "type": "boolean",
                "description": "When true (the default), the SIP servers received from the DHCP server will be collected and made available to client programs."
              },
              "UseMTU": {
                "type": "boolean",
                "default": false,
                "description": "When true, the interface maximum transmission unit from the DHCP server will be used on the current link. If MTUBytes= is set, then this setting is ignored. Defaults to false. Note, some drivers will reset the interfaces if the MTU is changed. For such interfaces, please try to use IgnoreCarrierLoss= with a short timespan, e.g. '3 seconds'."
              },
              "UseHostname": {
                "type": "boolean",
                "description": "When true (the default), the hostname received from the DHCP server will be set as the transient hostname of the system."
              },
              "UseDomains": {
                "type": "boolean",
                "default": false,
                "description": ", or the special value 'route'. When true, the domain name received from the DHCP server will be used as DNS search domain over this link, similarly to the effect of the 'Domains=' setting. If set to 'route', the domain name received from the DHCP server will be used for routing DNS queries only, but not for searching, similarly to the effect of the 'Domains=' setting when the argument is prefixed with '~'. When unspecified, the value specified in the same setting in the [Network] section will be used. When it is unspecified, the value specified in the same setting in the [DHCPv4] section in networkd.conf5 will be used. When it is unspecified, the value specified in the same setting in the [Network] section in networkd.conf5 will be used. When none of them are specified, defaults to 'no'. It is recommended to enable this option only on trusted networks, as setting this affects resolution of all hostnames, in particular of single-label names. It is generally safer to use the supplied domain only as routing domain, rather than as search domain, in order to not have it affect local resolution of single-label names. When set to true, this setting corresponds to the 'domain' option in resolv.conf5."
              },
              "UseRoutes": {
                "type": "boolean",
                "description": "When true (the default), the static routes will be requested from the DHCP server and added to the routing table with a metric of 1024, and a scope of 'global', 'link' or 'host', depending on the route's destination and gateway. If the destination is on the local host, e.g., 127.x.x.x, or the same as the link's own address, the scope will be set to 'host'. Otherwise if the gateway is null (a direct route), a 'link' scope will be used. For anything else, scope defaults to 'global'."
              },
              "RequestOptions": {
                "type": "string",
                "description": "Sets request options to be sent to the server in the DHCPv4 request options list. A whitespace-separated list of integers in the range 1...254. Defaults to unset."
              },
              "Anonymize": {
                "type": "boolean",
                "default": false,
                "description": "When true, the options sent to the DHCP server will follow the RFC 7844 (Anonymity Profiles for DHCP Clients) to minimize disclosure of identifying information. Defaults to false. This option should only be set to true when MACAddressPolicy= is set to 'random' (see systemd.link5). When true, ClientIdentifier=mac, RapidCommit=no, SendHostname=no, Use6RD=no, UseCaptivePortal=no, UseMTU=no, UseNTP=no, UseSIP=no, and UseTimezone=no are implied and these settings in the.network file are silently ignored. Also, Hostname=, MUDURL=, RequestAddress=, RequestOptions=, SendOption=, SendVendorOption=, UserClass=, and VendorClassIdentifier= are silently ignored. With this option enabled DHCP requests will mimic those generated by Microsoft Windows, in order to reduce the ability to fingerprint and recognize installations. This means DHCP request sizes will grow and lease data will be more comprehensive than normally, though most of the requested data is not actually used."
              },
              "SendHostname": {
                "type": "string",
                "description": "When true (the default), the machine's hostname (or the value specified with Hostname=, described below) will be sent to the DHCP server. Note that the hostname must consist only of 7-bit ASCII lower-case characters and no spaces or dots, and be formatted as a valid DNS domain name. Otherwise, the hostname is not sent even if this option is true."
              },
              "Hostname": {
                "type": "string",
                "description": "Use this value for the hostname which is sent to the DHCP server, instead of machine's hostname. Note that the specified hostname must consist only of 7-bit ASCII lower-case characters and no spaces or dots, and be formatted as a valid DNS domain name."
              },
              "RequestBroadcast": {
                "type": "boolean",
                "description": "Request the server to use broadcast messages before the IP address has been configured. This is necessary for devices that cannot receive RAW packets, or that cannot receive packets at all before an IP address has been configured. On the other hand, this must not be enabled on networks where broadcasts are filtered out."
              },
              "VendorClassIdentifier": {
                "type": "string",
                "description": "The vendor class identifier used to identify vendor type and configuration."
              },
              "MaxAttempts": {
                "type": "string",
                "default": "infinity",
                "description": "Specifies how many times the DHCPv4 client configuration should be attempted. Takes a number or 'infinity'. Defaults to 'infinity'. Note that the time between retries is increased exponentially, up to approximately one per minute, so the network will not be overloaded even if this number is high. The default is suitable in most circumstances."
              },
              "UserClass": {
                "type": "string",
                "description": "A DHCPv4 client can use UserClass option to identify the type or category of user or applications it represents. The information contained in this option is a string that represents the user class of which the client is a member. Each class sets an identifying string of information to be used by the DHCP service to classify clients. Takes a whitespace-separated list of strings."
              },
              "IAID": {
                "type": "string",
                "description": "The DHCP Identity Association Identifier (IAID) for the interface, a 32-bit unsigned integer."
              },
              "DUIDType": {
                "type": "string",
                "description": "Override the global DUIDType= setting for this network. See networkd.conf5 for a description of possible values."
              },
              "DUIDRawData": {
                "type": "string",
                "description": "Override the global DUIDRawData= setting for this network. See networkd.conf5 for a description of possible values."
              },
              "RouteMetric": {
                "type": "integer",
                "minimum": 0,
                "maximum": 4294967295,
                "default": 1024,
                "description": "Set the routing metric for routes specified by the DHCP server (including the prefix route added for the specified prefix). Takes an unsigned integer in the range 0...4294967295. Defaults to 1024."
              },
              "RouteTable": {
                "oneOf": [
                  {
                    "type": "string",
                    "enum": [
                      "default",
                      "local",
                      "main"
                    ]
                  },
                  {
                    "type": "integer",
                    "minimum": 1,
                    "maximum": 4294967295
                  }
                ],
                "description": "The table identifier for DHCP routes. conf5, or a number between 1...4294967295. When used in combination with VRF=, the VRF's routing table is used when this parameter is not specified."
              },
              "UseTimezone": {
                "type": "boolean",
                "default": false,
                "description": "When true, the timezone received from the DHCP server will be set as timezone of the local system. Defaults to false."
              },
              "ListenPort": {
                "type": "integer",
                "minimum": 1,
                "maximum": 65535,
                "description": "Set the port from which the DHCP client packets originate."
              },
              "SendRelease": {
                "type": "boolean",
                "default": true,
                "description": "When true, the DHCPv4 client sends a DHCP release packet when it stops. Defaults to true."
              },
              "IPServiceType": {
                "type": "string",
                "enum": [
                  "CS4",
                  "CS6",
                  "none"
                ],
                "default": "CS6",
                "description": "When 'none' no IP service type is set to the packet sent from the DHCPv4 client. When 'CS6' (network control) or 'CS4' (realtime), the corresponding service type will be set. Defaults to 'CS6'."
              },
              "SendOption": {
                "type": "string",
                "description": "Send an arbitrary raw option in the DHCPv4 request. Takes a DHCP option number, data type and data separated with a colon ('option:type:value'). The option number The type Special characters in the data string may be escaped using C-style escapes. This setting can be specified multiple times. If an empty string is specified, then all options specified earlier are cleared. Defaults to unset."
              },
              "BlackList": {
                "type": "string"
              },
              "UseDomainName": {
                "type": "string"
              },
              "CriticalConnection": {
                "type": "boolean"
              }
            },
            "additionalProperties": false
          }
        },
        {
          "type": "object",
          "description": "[DHCPv4] section configuration",
          "properties": {
            "RequestAddress": {
              "allOf": [
                {
                  "$ref": "#/definitions/ip_address"
                }
              ],
              "description": "Takes an IPv4 address. When specified, the Requested IP Address option (option code 50) is added with it to the initial DHCPDISCOVER message sent by the DHCP client. Defaults to unset, and an already assigned dynamic address to the interface is automatically picked."
            },
            "ClientIdentifier": {
              "type": "string",
              "enum": [
                "duid",
                "mac"
              ],
              "default": "duid",
              "description": "The DHCPv4 client identifier to use. If set to 'mac', the MAC address of the link is used. If set to 'duid', an RFC4361-compliant Client ID, which is the combination of IAID and DUID, is used. IAID can be configured by IAID=. DUID can be configured by DUIDType= and DUIDRawData=. Defaults to 'duid'."
            },
            "UseDNS": {
              "type": "boolean",
              "description": "When true (the default), the DNS servers received from the DHCP server will be used. This corresponds to the 'nameserver' option in resolv.conf5."
            },
            "UseDNR": {
              "type": "boolean",
              "description": "When true, designated resolvers advertised by the DHCP server will be used as encrypted DNS servers. See RFC 9463. Defaults to unset, and the value for UseDNS= will be used."
            },
            "RoutesToDNS": {
              "type": "boolean",
              "default": true,
              "description": "When true, the routes to the DNS servers received from the DHCP server will be configured. When UseDNS= is disabled, this setting is ignored. Defaults to true."
            },
            "UseNTP": {
              "type": "boolean",
              "description": "When true (the default), the NTP servers received from the DHCP server will be used by 'systemd-timesyncd.service'."
            },
            "RoutesToNTP": {
              "type": "boolean",
              "default": true,
              "description": "When true, the routes to the NTP servers received from the DHCP server will be configured. When UseNTP= is disabled, this setting is ignored. Defaults to true."
            },
            "UseSIP": {
              "type": "boolean",
              "description": "When true (the default), the SIP servers received from the DHCP server will be collected and made available to client programs."
            },
            "UseCaptivePortal": {
              "type": "boolean",
              "description": "When true (the default), the captive portal advertised by the DHCP server will be recorded and made available to client programs and displayed in the networkctl1 status output per-link."
            },
            "UseMTU": {
              "type": "boolean",
              "default": false,
              "description": "When true, the interface maximum transmission unit from the DHCP server will be used on the current link. If MTUBytes= is set, then this setting is ignored. Defaults to false. Note, some drivers will reset the interfaces if the MTU is changed. For such interfaces, please try to use IgnoreCarrierLoss= with a short timespan, e.g. '3 seconds'."
            },
            "UseHostname": {
              "type": "boolean",
              "description": "When true (the default), the hostname received from the DHCP server will be set as the transient hostname of the system."
            },
            "UseDomains": {
              "type": "boolean",
              "default": false,
              "description": ", or the special value 'route'. When true, the domain name received from the DHCP server will be used as DNS search domain over this link, similarly to the effect of the 'Domains=' setting. If set to 'route', the domain name received from the DHCP server will be used for routing DNS queries only, but not for searching, similarly to the effect of the 'Domains=' setting when the argument is prefixed with '~'. When unspecified, the value specified in the same setting in the [Network] section will be used. When it is unspecified, the value specified in the same setting in the [DHCPv4] section in networkd.conf5 will be used. When it is unspecified, the value specified in the same setting in the [Network] section in networkd.conf5 will be used. When none of them are specified, defaults to 'no'. It is recommended to enable this option only on trusted networks, as setting this affects resolution of all hostnames, in particular of single-label names. It is generally safer to use the supplied domain only as routing domain, rather than as search domain, in order to not have it affect local resolution of single-label names. When set to true, this setting corresponds to the 'domain' option in resolv.conf5."
            },
            "UseRoutes": {
              "type": "boolean",
              "description": "When true (the default), the static routes will be requested from the DHCP server and added to the routing table with a metric of 1024, and a scope of 'global', 'link' or 'host', depending on the route's destination and gateway. If the destination is on the local host, e.g., 127.x.x.x, or the same as the link's own address, the scope will be set to 'host'. Otherwise if the gateway is null (a direct route), a 'link' scope will be used. For anything else, scope defaults to 'global'."
            },
            "UseGateway": {
              "type": "boolean",
              "description": "When true, and the DHCP server provides a Router option, the default gateway based on the router address will be configured. Defaults to unset, and the value specified with UseRoutes= will be used. Note, when the server provides both the Router and Classless Static Routes option, and UseRoutes= is enabled, the Router option is always ignored regardless of this setting. See RFC 3442."
            },
            "QuickAck": {
              "type": "boolean",
              "description": "When true, the TCP quick ACK mode is enabled for the routes configured by the acquired DHCPv4 lease. When unset, the kernel's default will be used."
            },
            "RequestOptions": {
              "type": "string",
              "description": "Sets request options to be sent to the server in the DHCPv4 request options list. A whitespace-separated list of integers in the range 1...254. Defaults to unset."
            },
            "Anonymize": {
              "type": "boolean",
              "default": false,
              "description": "When true, the options sent to the DHCP server will follow the RFC 7844 (Anonymity Profiles for DHCP Clients) to minimize disclosure of identifying information. Defaults to false. This option should only be set to true when MACAddressPolicy= is set to 'random' (see systemd.link5). When true, ClientIdentifier=mac, RapidCommit=no, SendHostname=no, Use6RD=no, UseCaptivePortal=no, UseMTU=no, UseNTP=no, UseSIP=no, and UseTimezone=no are implied and these settings in the.network file are silently ignored. Also, Hostname=, MUDURL=, RequestAddress=, RequestOptions=, SendOption=, SendVendorOption=, UserClass=, and VendorClassIdentifier= are silently ignored. With this option enabled DHCP requests will mimic those generated by Microsoft Windows, in order to reduce the ability to fingerprint and recognize installations. This means DHCP request sizes will grow and lease data will be more comprehensive than normally, though most of the requested data is not actually used."
            },
            "SendHostname": {
              "type": "string",
              "description": "When true (the default), the machine's hostname (or the value specified with Hostname=, described below) will be sent to the DHCP server. Note that the hostname must consist only of 7-bit ASCII lower-case characters and no spaces or dots, and be formatted as a valid DNS domain name. Otherwise, the hostname is not sent even if this option is true."
            },
            "Hostname": {
              "type": "string",
              "description": "Use this value for the hostname which is sent to the DHCP server, instead of machine's hostname. Note that the specified hostname must consist only of 7-bit ASCII lower-case characters and no spaces or dots, and be formatted as a valid DNS domain name."
            },
            "Label": {
              "type": "string",
              "description": "Specifies the label for the IPv4 address received from the DHCP server. The label must be a 7-bit ASCII string with a length of 1...15 characters. Defaults to unset."
            },
            "RequestBroadcast": {
              "type": "boolean",
              "description": "Request the server to use broadcast messages before the IP address has been configured. This is necessary for devices that cannot receive RAW packets, or that cannot receive packets at all before an IP address has been configured. On the other hand, this must not be enabled on networks where broadcasts are filtered out."
            },
            "VendorClassIdentifier": {
              "type": "string",
              "description": "The vendor class identifier used to identify vendor type and configuration."
            },
            "MUDURL": {
              "type": "string",
              "description": "When configured, the specified Manufacturer Usage Description (MUD) URL will be sent to the DHCPv4 server. Takes a URL of length up to 255 characters. A superficial verification that the string is a valid URL will be performed. DHCPv4 clients are intended to have at most one MUD URL associated with them. See RFC 8520. MUD is an embedded software standard defined by the IETF that allows IoT device makers to advertise device specifications, including the intended communication patterns for their device when it connects to the network. The network can then use this to author a context-specific access policy, so the device functions only within those parameters."
            },
            "MaxAttempts": {
              "oneOf": [
                {
                  "type": "string",
                  "enum": [
                    "infinity"
                  ]
                },
                {
                  "type": "integer"
                }
              ],
              "default": "infinity",
              "description": "Specifies how many times the DHCPv4 client configuration should be attempted. Takes a number or 'infinity'. Defaults to 'infinity'. Note that the time between retries is increased exponentially, up to approximately one per minute, so the network will not be overloaded even if this number is high. The default is suitable in most circumstances."
            },
            "UserClass": {
              "type": "string",
              "description": "A DHCPv4 client can use UserClass option to identify the type or category of user or applications it represents. The information contained in this option is a string that represents the user class of which the client is a member. Each class sets an identifying string of information to be used by the DHCP service to classify clients. Takes a whitespace-separated list of strings."
            },
            "IAID": {
              "type": "string",
              "description": "The DHCP Identity Association Identifier (IAID) for the interface, a 32-bit unsigned integer."
            },
            "DUIDType": {
              "type": "string",
              "description": "Override the global DUIDType= setting for this network. See networkd.conf5 for a description of possible values."
            },
            "DUIDRawData": {
              "type": "string",
              "description": "Override the global DUIDRawData= setting for this network. See networkd.conf5 for a description of possible values."
            },
            "RouteMetric": {
              "type": "integer",
              "minimum": 0,
              "maximum": 4294967295,
              "default": 1024,
              "description": "Set the routing metric for routes specified by the DHCP server (including the prefix route added for the specified prefix). Takes an unsigned integer in the range 0...4294967295. Defaults to 1024."
            },
            "RouteTable": {
              "oneOf": [
                {
                  "type": "string",
                  "enum": [
                    "default",
                    "local",
                    "main"
                  ]
                },
                {
                  "type": "integer",
                  "minimum": 1,
                  "maximum": 4294967295
                }
              ],
              "description": "The table identifier for DHCP routes. conf5, or a number between 1...4294967295. When used in combination with VRF=, the VRF's routing table is used when this parameter is not specified."
            },
            "UseTimezone": {
              "type": "boolean",
              "default": false,
              "description": "When true, the timezone received from the DHCP server will be set as timezone of the local system. Defaults to false."
            },
            "ListenPort": {
              "type": "integer",
              "minimum": 1,
              "maximum": 65535,
              "description": "Set the port from which the DHCP client packets originate."
            },
            "ServerPort": {
              "type": "integer",
              "minimum": 1,
              "maximum": 65535,
              "description": "Set the port on which the DHCP server is listening."
            },
            "SendRelease": {
              "type": "boolean",
              "default": true,
              "description": "When true, the DHCPv4 client sends a DHCP release packet when it stops. Defaults to true."
            },
            "SendDecline": {
              "type": "boolean",
              "default": false,
              "description": "A boolean. When true, systemd-networkd performs IPv4 Duplicate Address Detection to the acquired address by the DHCPv4 client. If duplicate is detected, the DHCPv4 client rejects the address by sending a 'DHCPDECLINE' packet to the DHCP server, and tries to obtain an IP address again. See RFC 5227. Defaults to false."
            },
            "DenyList": {
              "type": "string",
              "description": "A whitespace-separated list of IPv4 addresses. Each address can optionally take a prefix length after '/'. DHCP offers from servers in the list are rejected. Note that if AllowList= is configured then DenyList= is ignored. Note that this filters only DHCP offers, so the filtering might not work when RapidCommit= is enabled. See also RapidCommit= above."
            },
            "AllowList": {
              "type": "string",
              "description": "A whitespace-separated list of IPv4 addresses. Each address can optionally take a prefix length after '/'. DHCP offers from servers in the list are accepted. Note that this filters only DHCP offers, so the filtering might not work when RapidCommit= is enabled. See also RapidCommit= in the above."
            },
            "IPServiceType": {
              "type": "string",
              "enum": [
                "CS4",
                "CS6",
                "none"
              ],
              "default": "CS6",
              "description": "When 'none' no IP service type is set to the packet sent from the DHCPv4 client. When 'CS6' (network control) or 'CS4' (realtime), the corresponding service type will be set. Defaults to 'CS6'."
            },
            "SocketPriority": {
              "type": "string",
              "description": "The Linux socket option 'SO_PRIORITY' applied to the raw IP socket used for initial DHCPv4 messages. Unset by default. Usual values range from 0 to 6. More details about 'SO_PRIORITY' socket option in socket7. Can be used in conjunction with [VLAN] section EgressQOSMaps= setting of.netdev file to set the 802.1Q VLAN ethernet tagged header priority, see systemd.netdev5."
            },
            "SendOption": {
              "type": "string",
              "description": "Send an arbitrary raw option in the DHCPv4 request. Takes a DHCP option number, data type and data separated with a colon ('option:type:value'). The option number The type Special characters in the data string may be escaped using C-style escapes. This setting can be specified multiple times. If an empty string is specified, then all options specified earlier are cleared. Defaults to unset."
            },
            "SendVendorOption": {
              "type": "string",
              "description": "Send an arbitrary vendor option in the DHCPv4 request. Takes a DHCP option number, data type and data separated with a colon ('option:type:value'). The option number The type Special characters in the data string may be escaped using C-style escapes. This setting can be specified multiple times. If an empty string is specified, then all options specified earlier are cleared. Defaults to unset."
            },
            "RouteMTUBytes": {
              "type": "integer",
              "minimum": 68,
              "description": "Specifies the MTU for the DHCP routes. Please see the [Route] section for further details."
            },
            "InitialCongestionWindow": {
              "type": "integer",
              "minimum": 1,
              "maximum": 1023,
              "description": "As in the [Route] section."
            },
            "InitialAdvertisedReceiveWindow": {
              "allOf": [
                {
                  "$ref": "#/definitions/bytes"
                }
              ],
              "description": "As in the [Route] section."
            },
            "FallbackLeaseLifetimeSec": {
              "oneOf": [
                {
                  "type": "string",
                  "enum": [
                    "forever",
                    "infinity"
                  ]
                },
                {
                  "type": "integer",
                  "minimum": 0
                }
              ],
              "description": "Allows one to set DHCPv4 lease lifetime when DHCPv4 server does not send the lease lifetime. If specified, the acquired address never expires. Defaults to unset."
            },
            "Use6RD": {
              "type": "boolean",
              "default": false,
              "description": "When true, subnets of the received IPv6 prefix are assigned to downstream interfaces which enables DHCPPrefixDelegation=. See also DHCPPrefixDelegation= in the [Network] section, the [DHCPPrefixDelegation] section, and RFC 5969. Defaults to false."
            },
            "UnassignedSubnetPolicy": {
              "type": "string",
              "default": "unreachable",
              "description": "Takes 'none', or one of the reject types: 'unreachable', 'prohibit', 'blackhole', or 'throw'. If a reject type is specified, the reject route corresponding to the acquired 6RD prefix will be configured. For example, when 'unreachable', unreachable 2001:db8::/56 dev lo proto dhcp metric 1024 pref medium will be configured. See RFC 7084. If 'none' is specified, such route will not be configured. This may be useful when custom firewall rules that handle packets for unassigned subnets will be configured. Defaults to 'unreachable'."
            },
            "IPv6OnlyMode": {
              "type": "boolean",
              "default": false,
              "description": "When true, the DHCPv4 configuration will be delayed by the timespan provided by the DHCP server and skip to configure dynamic IPv4 network connectivity if IPv6 connectivity is provided within the timespan. See RFC 8925. Defaults to false."
            },
            "NetLabel": {
              "type": "string",
              "description": "This applies the NetLabel for the addresses received with DHCP, like NetLabel= in [Address] section applies it to statically configured addresses. See NetLabel= in [Address] section for more details."
            },
            "NFTSet": {
              "type": "string",
              "description": "This applies the NFT set for the network configuration received with DHCP, like NFTSet= in [Address] section applies it to static configuration. See NFTSet= in [Address] section for more details. For 'address' or 'prefix' source types, the type of the element used in the NFT filter must be 'ipv4_addr'."
            },
            "RapidCommit": {
              "type": "boolean",
              "default": true,
              "description": "The DHCPv4 client can obtain configuration parameters from a DHCPv4 server through a rapid two-message exchange (discover and ack). When the rapid commit option is set by both the DHCPv4 client and the DHCPv4 server, the two-message exchange is used. Otherwise, the four-message exchange (discover, offer, request, and ack) is used. The two-message exchange provides faster client configuration. See RFC 4039 for details. Defaults to true when Anonymize=no and neither AllowList= nor DenyList= is specified, and false otherwise."
            },
            "BlackList": {
              "type": "string"
            },
            "UseDomainName": {
              "type": "string"
            },
            "CriticalConnection": {
              "type": "boolean"
            }
          },
          "additionalProperties": false
        }
      ],
      "description": "[DHCPv4] configuration (Can be repeated)",
      "title": "DHC Pv4"
    },
    "DHCPv6": {
      "oneOf": [
        {
          "type": "array",
          "items": {
            "type": "object",
            "description": "[DHCPv6] section configuration",
            "properties": {
              "UseDNS": {
                "type": "boolean",
                "description": "As in the [DHCPv4] section."
              },
              "UseNTP": {
                "type": "boolean",
                "description": "When true (the default), the NTP servers received from the DHCP server will be used by 'systemd-timesyncd.service'."
              },
              "PrefixDelegationHint": {
                "allOf": [
                  {
                    "$ref": "#/definitions/ipv6_prefix"
                  }
                ],
                "description": "Takes an IPv6 address with prefix length in the same format as the Address= in the [Network] section. The DHCPv6 client will include a prefix hint in the DHCPv6 solicitation sent to the server. The prefix length Defaults to unset."
              },
              "RapidCommit": {
                "type": "boolean",
                "default": true,
                "description": "The DHCPv6 client can obtain configuration parameters from a DHCPv6 server through a rapid two-message exchange (solicit and reply). When the rapid commit option is set by both the DHCPv6 client and the DHCPv6 server, the two-message exchange is used. Otherwise, the four-message exchange (solicit, advertise, request, and reply) is used. The two-message exchange provides faster client configuration. See RFC 3315 for details. Defaults to true, and the two-message exchange will be used if the server support it."
              },
              "ForceDHCPv6PDOtherInformation": {
                "type": "boolean"
              }
            },
            "additionalProperties": false
          }
        },
        {
          "type": "object",
          "description": "[DHCPv6] section configuration",
          "properties": {
            "UseAddress": {
              "type": "boolean",
              "description": "When true (the default), the IP addresses provided by the DHCPv6 server will be assigned."
            },
            "UseDelegatedPrefix": {
              "type": "boolean",
              "description": "When true (the default), the client will request the DHCPv6 server to delegate prefixes. If the server provides prefixes to be delegated, then subnets of the prefixes are assigned to the interfaces that have DHCPPrefixDelegation=yes. See also the DHCPPrefixDelegation= setting in the [Network] section, settings in the [DHCPPrefixDelegation] section, and RFC 8415."
            },
            "UseDNS": {
              "type": "boolean",
              "description": "As in the [DHCPv4] section."
            },
            "UseDNR": {
              "type": "boolean",
              "description": "When true, designated resolvers advertised by the DHCP server will be used as encrypted DNS servers. See RFC 9463. Defaults to unset, and the value for UseDNS= will be used."
            },
            "UseHostname": {
              "type": "boolean",
              "description": "When true (the default), the hostname received from the DHCP server will be set as the transient hostname of the system."
            },
            "UseDomains": {
              "type": "boolean",
              "description": "Specifies the protocol-independent default value for the same settings in [IPv6AcceptRA], [DHCPv4], and [DHCPv6] sections below. Takes a boolean, or the special value 'route'. See also the same setting in [DHCPv4] below. Defaults to unset."
            },
            "UseNTP": {
              "type": "boolean",
              "description": "When true (the default), the NTP servers received from the DHCP server will be used by 'systemd-timesyncd.service'."
            },
            "UseCaptivePortal": {
              "type": "boolean",
              "description": "When true (the default), the captive portal advertised by the DHCPv6 server will be recorded and made available to client programs and displayed in the networkctl1 status output per-link."
            },
            "MUDURL": {
              "type": "string",
              "description": "As in the [DHCPv4] section."
            },
            "SendHostname": {
              "type": "string",
              "description": "When true (the default), the machine's hostname (or the value specified with Hostname=, described below) will be sent to the DHCPv6 server. Note that the hostname must consist only of 7-bit ASCII lower-case characters and no spaces or dots, and be formatted as a valid DNS domain name. Otherwise, the hostname is not sent even if this option is true."
            },
            "Hostname": {
              "type": "string",
              "description": "Use this value for the hostname which is sent to the DHCPv6 server, instead of machine's hostname. Note that the specified hostname must consist only of 7-bit ASCII lower-case characters and no spaces or dots, and be formatted as a valid DNS domain name."
            },
            "RequestOptions": {
              "type": "string",
              "description": "Sets request options to be sent to the server in the DHCPv4 request options list. A whitespace-separated list of integers in the range 1...254. Defaults to unset."
            },
            "UserClass": {
              "type": "string",
              "description": "A DHCPv6 client can use User Class option to identify the type or category of user or applications it represents. The information contained in this option is a string that represents the user class of which the client is a member. Each class sets an identifying string of information to be used by the DHCP service to classify clients. Special characters in the data string may be escaped using C-style escapes. This setting can be specified multiple times. If an empty string is specified, then all options specified earlier are cleared. Takes a whitespace-separated list of strings. Note that currently 'NUL' bytes are not allowed."
            },
            "VendorClass": {
              "type": "string",
              "description": "A DHCPv6 client can use VendorClass option to identify the vendor that manufactured the hardware on which the client is running. The information contained in the data area of this option is contained in one or more opaque fields that identify details of the hardware configuration. Takes a whitespace-separated list of strings."
            },
            "SendVendorOption": {
              "type": "string",
              "description": "Send an arbitrary vendor option in the DHCPv6 request. Takes an enterprise identifier, DHCP option number, data type, and data separated with a colon ('enterprise identifier:option:type:value'). Enterprise identifier is an unsigned integer in the range 1...4294967294. The option number Data type Special characters in the data string may be escaped using C-style escapes. This setting can be specified multiple times. If an empty string is specified, then all options specified earlier are cleared. Defaults to unset."
            },
            "PrefixDelegationHint": {
              "allOf": [
                {
                  "$ref": "#/definitions/ipv6_prefix"
                }
              ],
              "description": "Takes an IPv6 address with prefix length in the same format as the Address= in the [Network] section. The DHCPv6 client will include a prefix hint in the DHCPv6 solicitation sent to the server. The prefix length Defaults to unset."
            },
            "UnassignedSubnetPolicy": {
              "type": "string",
              "enum": [
                "none",
                "unreachable",
                "prohibit",
                "blackhole",
                "throw"
              ],
              "default": "unreachable",
              "description": "Takes 'none' or one of the reject types: 'unreachable', 'prohibit', 'blackhole', or 'throw'. If a reject type is specified, the reject route corresponding to the delegated prefix will be configured. For example, when 'unreachable', unreachable 2001:db8::/56 dev lo proto dhcp metric 1024 pref medium will be configured. See RFC 7084. If 'none' is specified, such route will not be configured. This may be useful when custom firewall rules that handle packets for unassigned subnets will be configured. Defaults to 'unreachable'."
            },
            "WithoutRA": {
              "type": "string",
              "enum": [
                "information-request",
                "no",
                "solicit"
              ],
              "default": "no",
              "description": "Allows DHCPv6 client to start without router advertisements's 'managed' or 'other configuration' flag. If this is not specified, 'solicit' is used when DHCPPrefixDelegation= is enabled and UplinkInterface=:self is specified in the [DHCPPrefixDelegation] section. Otherwise, defaults to 'no', and the DHCPv6 client will be started when an RA is received. See also the DHCPv6Client= setting in the [IPv6AcceptRA] section."
            },
            "SendOption": {
              "type": "string",
              "description": "As in the [DHCPv4] section, however because DHCPv6 uses 16-bit fields to store option numbers, the option number is an integer in the range 1...65536."
            },
            "IAID": {
              "type": "string",
              "description": "The DHCP Identity Association Identifier (IAID) for the interface, a 32-bit unsigned integer."
            },
            "DUIDType": {
              "type": "string",
              "description": "Override the global DUIDType= setting for this network. See networkd.conf5 for a description of possible values."
            },
            "DUIDRawData": {
              "type": "string",
              "description": "Override the global DUIDRawData= setting for this network. See networkd.conf5 for a description of possible values."
            },
            "RapidCommit": {
              "type": "boolean",
              "default": true,
              "description": "The DHCPv6 client can obtain configuration parameters from a DHCPv6 server through a rapid two-message exchange (solicit and reply). When the rapid commit option is set by both the DHCPv6 client and the DHCPv6 server, the two-message exchange is used. Otherwise, the four-message exchange (solicit, advertise, request, and reply) is used. The two-message exchange provides faster client configuration. See RFC 3315 for details. Defaults to true, and the two-message exchange will be used if the server support it."
            },
            "NetLabel": {
              "type": "string",
              "description": "This setting provides a method for integrating static and dynamic network configuration into Linux NetLabel subsystem rules, used by Linux Security Modules (LSMs) for network access control. The label, with suitable LSM rules, can be used to control connectivity of (for example) a service with peers in the local network. At least with SELinux, only the ingress can be controlled but not egress. The benefit of using this setting is that it may be possible to apply interface independent part of NetLabel configuration at very early stage of system boot sequence, at the time when the network interfaces are not available yet, with netlabelctl8, and the per-interface configuration with systemd-networkd once the interfaces appear later. Currently this feature is only implemented for SELinux. The option expects a single NetLabel label. The label must conform to lexical restrictions of LSM labels. When an interface is configured with IP addresses, the addresses and subnetwork masks will be appended to the NetLabel Fallback Peer Labeling rules. They will be removed when the interface is deconfigured. Failures to manage the labels will be ignored. Once labeling is enabled for network traffic, a lot of LSM access control points in Linux networking stack go from dormant to active. Care should be taken to avoid getting into a situation where for example remote connectivity is broken, when the security policy hasn't been updated to consider LSM per-packet access controls and no rules would allow any network traffic. Also note that additional configuration with netlabelctl8 is needed. Example: [Address] NetLabel=system_u:object_r:localnet_peer_t:s0 With the example rules applying for interface 'eth0', when the interface is configured with an IPv4 address of 10.0.0.123/8, systemd-networkd performs the equivalent of netlabelctl operation netlabelctl unlbl add interface eth0 address:10.0.0.0/8 label:system_u:object_r:localnet_peer_t:s0 and the reverse operation when the IPv4 address is deconfigured. The configuration can be used with LSM rules; in case of SELinux to allow a SELinux domain to receive data from objects of SELinux 'peer' class. For example: type localnet_peer_t; allow my_server_t localnet_peer_t:peer recv; The effect of the above configuration and rules (in absence of other rules as may be the case) is to only allow 'my_server_t' (and nothing else) to receive data from local subnet 10.0.0.0/8 of interface 'eth0'."
            },
            "SendRelease": {
              "type": "boolean",
              "default": true,
              "description": "When true, the DHCPv4 client sends a DHCP release packet when it stops. Defaults to true."
            },
            "NFTSet": {
              "type": "string",
              "description": "This applies the NFT set for the network configuration received with DHCP, like NFTSet= in [Address] section applies it to static configuration. See NFTSet= in [Address] section for more details. For 'address' or 'prefix' source types, the type of the element used in the NFT filter must be 'ipv6_addr'."
            },
            "RouteMetric": {
              "type": "integer",
              "minimum": 0,
              "maximum": 4294967295,
              "description": "The metric of the prefix route, which is pointing to the subnet of the configured IP address, taking the configured prefix length into account. Takes an unsigned integer in the range 0...4294967295. When unset or set to 0, the kernel's default value is used. This setting will be ignored when AddPrefixRoute= is false."
            },
            "ForceDHCPv6PDOtherInformation": {
              "type": "boolean"
            }
          },
          "additionalProperties": false
        }
      ],
      "description": "[DHCPv6] configuration (Can be repeated)",
      "title": "DHC Pv6"
    },
    "IPv6AcceptRA": {
      "oneOf": [
        {
          "type": "array",
          "items": {
            "type": "object",
            "description": "[IPv6AcceptRA] section configuration",
            "properties": {
              "UseAutonomousPrefix": {
                "type": "boolean",
                "description": "When true (the default), the autonomous prefix received in the Router Advertisement will be used and take precedence over any statically configured ones."
              },
              "UseOnLinkPrefix": {
                "type": "boolean",
                "description": "When true (the default), the onlink prefix received in the Router Advertisement will be used and takes precedence over any statically configured ones."
              },
              "UseDNS": {
                "type": "boolean",
                "description": "When true (the default), the DNS servers received in the Router Advertisement will be used. This corresponds to the 'nameserver' option in resolv.conf5."
              },
              "UseDomains": {
                "type": "boolean",
                "default": false,
                "description": ", or the special value 'route'. When true, the domain name received via IPv6 Router Advertisement (RA) will be used as DNS search domain over this link, similarly to the effect of the 'Domains=' setting. If set to 'route', the domain name received via IPv6 RA will be used for routing DNS queries only, but not for searching, similarly to the effect of the 'Domains=' setting when the argument is prefixed with '~'. Defaults to false. It is recommended to enable this option only on trusted networks, as setting this affects resolution of all hostnames, in particular of single-label names. It is generally safer to use the supplied domain only as routing domain, rather than as search domain, in order to not have it affect local resolution of single-label names. When set to true, this setting corresponds to the 'domain' option in resolv.conf5."
              },
              "RouteTable": {
                "type": "string",
                "enum": [
                  "default",
                  "local",
                  "main"
                ],
                "description": "The table identifier for the routes received in the Router Advertisement. conf5, or a number between 1...4294967295. When used in combination with VRF=, the VRF's routing table is used when this parameter is not specified."
              },
              "BlackList": {
                "type": "string"
              }
            },
            "additionalProperties": false,
            "required": [
              "Token"
            ]
          }
        },
        {
          "type": "object",
          "description": "[IPv6AcceptRA] section configuration",
          "properties": {
            "UseRedirect": {
              "type": "boolean",
              "description": "When true (the default), Redirect message sent by the current first-hop router will be accepted, and routes to redirected nodes will be configured."
            },
            "UseGateway": {
              "type": "boolean",
              "description": "When true (the default), the router address will be configured as the default gateway."
            },
            "UseRoutePrefix": {
              "type": "boolean",
              "description": "When true (the default), the routes corresponding to the route prefixes received in the Router Advertisement will be configured."
            },
            "UseAutonomousPrefix": {
              "type": "boolean",
              "description": "When true (the default), the autonomous prefix received in the Router Advertisement will be used and take precedence over any statically configured ones."
            },
            "UseOnLinkPrefix": {
              "type": "boolean",
              "description": "When true (the default), the onlink prefix received in the Router Advertisement will be used and takes precedence over any statically configured ones."
            },
            "UsePREF64": {
              "type": "boolean",
              "default": false,
              "description": "When true, the IPv6 PREF64 (or NAT64) prefixes received in the Router Advertisement will be recorded and made available to client programs and displayed in the networkctl1 status output per-link. See RFC 8781. Defaults to false."
            },
            "UseDNS": {
              "type": "boolean",
              "description": "When true (the default), the DNS servers received in the Router Advertisement will be used. This corresponds to the 'nameserver' option in resolv.conf5."
            },
            "UseDNR": {
              "type": "boolean",
              "description": "When true, the DNR servers received in the Router Advertisement will be used. Defaults to the value of 'UseDNS='."
            },
            "UseDomains": {
              "oneOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "string",
                  "enum": [
                    "route"
                  ]
                }
              ],
              "default": false,
              "description": ", or the special value 'route'. When true, the domain name received via IPv6 Router Advertisement (RA) will be used as DNS search domain over this link, similarly to the effect of the 'Domains=' setting. If set to 'route', the domain name received via IPv6 RA will be used for routing DNS queries only, but not for searching, similarly to the effect of the 'Domains=' setting when the argument is prefixed with '~'. Defaults to false. It is recommended to enable this option only on trusted networks, as setting this affects resolution of all hostnames, in particular of single-label names. It is generally safer to use the supplied domain only as routing domain, rather than as search domain, in order to not have it affect local resolution of single-label names. When set to true, this setting corresponds to the 'domain' option in resolv.conf5."
            },
            "UseMTU": {
              "type": "boolean",
              "default": true,
              "description": "When true, the MTU received in the Router Advertisement will be used. Defaults to true."
            },
            "UseHopLimit": {
              "type": "boolean",
              "default": true,
              "description": "When true, the hop limit received in the Router Advertisement will be set to routes configured based on the advertisement. See also IPv6HopLimit=. Defaults to true."
            },
            "UseReachableTime": {
              "type": "boolean",
              "default": true,
              "description": "When true, the reachable time received in the Router Advertisement will be set on the interface receiving the advertisement. It is used as the base timespan of the validity of a neighbor entry. Defaults to true."
            },
            "UseRetransmissionTime": {
              "type": "boolean",
              "default": true,
              "description": "When true, the retransmission time received in the Router Advertisement will be set on the interface receiving the advertisement. It is used as the time between retransmissions of Neighbor Solicitation messages to a neighbor when resolving the address or when probing the reachability of a neighbor. Defaults to true."
            },
            "DHCPv6Client": {
              "type": "boolean",
              "default": true,
              "description": ", or the special value 'always'. When true, the DHCPv6 client will be started in 'solicit' mode if the RA has the 'managed' flag or 'information-request' mode if the RA lacks the 'managed' flag but has the 'other configuration' flag. If set to 'always', the DHCPv6 client will be started in 'solicit' mode when an RA is received, even if neither the 'managed' nor the 'other configuration' flag is set in the RA. This will be ignored when WithoutRA= in the [DHCPv6] section is enabled, or UplinkInterface=:self in the [DHCPPrefixDelegation] section is specified. Defaults to true."
            },
            "RouteTable": {
              "oneOf": [
                {
                  "type": "string"
                },
                {
                  "type": "integer",
                  "minimum": 1,
                  "maximum": 4294967295
                }
              ],
              "description": "The table identifier for the routes received in the Router Advertisement. conf5, or a number between 1...4294967295. When used in combination with VRF=, the VRF's routing table is used when this parameter is not specified."
            },
            "RouteMetric": {
              "oneOf": [
                {
                  "type": "integer",
                  "minimum": 0,
                  "maximum": 4294967295
                },
                {
                  "type": "string",
                  "pattern": "^[0-9]+:[0-9]+:[0-9]+$"
                }
              ],
              "default": "512:1024:2048",
              "description": "Set the routing metric for the routes received in the Router Advertisement. Takes an unsigned integer in the range 0...4294967295, or three unsigned integer separated with ':', in that case the first one is used when the router preference is high, the second is for medium preference, and the last is for low preference ('high:medium:low'). Defaults to '512:1024:2048'."
            },
            "QuickAck": {
              "type": "boolean",
              "description": "When true, the TCP quick ACK mode is enabled for the routes configured by the received RAs. When unset, the kernel's default will be used."
            },
            "UseCaptivePortal": {
              "type": "boolean",
              "description": "When true (the default), the captive portal received in the Router Advertisement will be recorded and made available to client programs and displayed in the networkctl1 status output per-link."
            },
            "RouterAllowList": {
              "type": "string",
              "description": "A whitespace-separated list of IPv6 router addresses. Each address can optionally take a prefix length after '/'. Only information advertised by the listed router is accepted. Note that if RouterAllowList= is configured then RouterDenyList= is ignored."
            },
            "RouterDenyList": {
              "type": "string",
              "description": "A whitespace-separated list of IPv6 router addresses. Each address can optionally take a prefix length after '/'. Any information advertised by the listed router is ignored."
            },
            "PrefixAllowList": {
              "type": "string",
              "description": "A whitespace-separated list of IPv6 prefixes. Each prefix can optionally take its prefix length after '/'. IPv6 prefixes supplied via router advertisements in the list are allowed. Note that if PrefixAllowList= is configured then PrefixDenyList= is ignored."
            },
            "PrefixDenyList": {
              "type": "string",
              "description": "A whitespace-separated list of IPv6 prefixes. Each prefix can optionally take its prefix length after '/'. IPv6 prefixes supplied via router advertisements in the list are ignored."
            },
            "RouteAllowList": {
              "type": "string",
              "description": "A whitespace-separated list of IPv6 route prefixes. Each prefix can optionally take its prefix length after '/'. IPv6 route prefixes supplied via router advertisements in the list are allowed. Note that if RouteAllowList= is configured then RouteDenyList= is ignored."
            },
            "RouteDenyList": {
              "type": "string",
              "description": "A whitespace-separated list of IPv6 route prefixes. Each prefix can optionally take its prefix length after '/'. IPv6 route prefixes supplied via router advertisements in the list are ignored."
            },
            "Token": {
              "type": "string",
              "description": "Specifies an optional address generation mode for the Stateless Address Autoconfiguration (SLAAC). The following values are supported: The EUI-64 algorithm will be used to generate an address for that prefix. Only supported by Ethernet or InfiniBand interfaces. An IPv6 address must be specified after a colon (':'), and the lower bits of the supplied address are combined with the upper bits of a prefix received in a Router Advertisement (RA) message to form a complete address. Note that if multiple prefixes are received in an RA message, or in multiple RA messages, addresses will be formed from each of them using the supplied address. This mode implements SLAAC but uses a static interface identifier instead of an identifier generated by using the EUI-64 algorithm. Because the interface identifier is static, if Duplicate Address Detection detects that the computed address is a duplicate (in use by another node on the link), then this mode will fail to provide an address for that prefix. If an IPv6 address without mode is specified, then 'static' mode is assumed. The algorithm specified in RFC 7217 will be used to generate interface identifiers. This mode can optionally take an IPv6 address separated with a colon (':'). If an IPv6 address is specified, then an interface identifier is generated only when a prefix received in an RA message matches the supplied address. This mode can also optionally take a non-null UUID in the format which sd_id128_from_string() accepts, e.g. '86b123b969ba4b7eb8b3d8605123525a' or '86b123b9-69ba-4b7e-b8b3-d8605123525a'. If a UUID is specified, the value is used as the secret key to generate interface identifiers. If not specified, then an application specific ID generated with the system's machine-ID will be used as the secret key. See sd-id1283, sd_id128_from_string3, and sd_id128_get_machine3. Note that the 'prefixstable' algorithm uses both the interface name and MAC address as input to the hash to compute the interface identifier, so if either of those are changed the resulting interface identifier (and address) will be changed, even if the prefix received in the RA message has not been changed. If no address generation mode is specified (which is the default), or a received prefix does not match any of the addresses provided in 'prefixstable' mode, then the EUI-64 algorithm will be used for Ethernet or InfiniBand interfaces, otherwise 'prefixstable' will be used to form an interface identifier for that prefix. This setting can be specified multiple times. If an empty string is assigned, then the all previous assignments are cleared. Examples: Token=eui64 Token=::1a:2b:3c:4d Token=static:::1a:2b:3c:4d Token=prefixstable Token=prefixstable:2002:da8:1::"
            },
            "NetLabel": {
              "type": "string",
              "description": "This applies the NetLabel for the addresses received with RA, like NetLabel= in [Address] section applies it to statically configured addresses. See NetLabel= in [Address] section for more details."
            },
            "NFTSet": {
              "type": "string",
              "description": "This applies the NFT set for the network configuration received with RA, like NFTSet= in [Address] section applies it to static configuration. See NFTSet= in [Address] section for more details. For 'address' or 'prefix' source types, the type of the element used in the NFT filter must be 'ipv6_addr'."
            },
            "DenyList": {
              "type": "string",
              "description": "A whitespace-separated list of IPv4 addresses. Each address can optionally take a prefix length after '/'. DHCP offers from servers in the list are rejected. Note that if AllowList= is configured then DenyList= is ignored. Note that this filters only DHCP offers, so the filtering might not work when RapidCommit= is enabled. See also RapidCommit= above."
            },
            "BlackList": {
              "type": "string"
            },
            "UseICMP6RateLimit": {
              "type": "string"
            }
          },
          "additionalProperties": false,
          "required": [
            "Token"
          ]
        }
      ],
      "description": "[IPv6AcceptRA] configuration (Can be repeated)",
      "title": "I Pv6 Accept RA",
      "examples": [
        "yes",
        "no"
      ]
    },
    "DHCPServer": {
      "oneOf": [
        {
          "type": "array",
          "items": {
            "type": "object",
            "description": "[DHCPServer] section configuration",
            "properties": {
              "MaxLeaseTimeSec": {
                "$ref": "#/definitions/seconds"
              },
              "DefaultLeaseTimeSec": {
                "allOf": [
                  {
                    "$ref": "#/definitions/seconds"
                  }
                ],
                "description": "Control the default and maximum DHCP lease time to pass to clients. These settings take time values in seconds or another common time unit, depending on the suffix. The default lease time is used for clients that did not ask for a specific lease time. If a client asks for a lease time longer than the maximum lease time, it is automatically shortened to the specified time. The default lease time defaults to 1h, the maximum lease time to 12h. Shorter lease times are beneficial if the configuration data in DHCP leases changes frequently and clients shall learn the new settings with shorter latencies. Longer lease times reduce the generated DHCP network traffic.",
                "default": "1h"
              },
              "EmitDNS": {
                "type": "boolean",
                "default": true,
                "description": "EmitDNS= takes a boolean. Configures whether the DHCP leases handed out to clients shall contain DNS server information. Defaults to 'yes'. The DNS servers to pass to clients may be configured with the DNS= option, which takes a list of IPv4 addresses, or special value '_server_address' which will be converted to the address used by the DHCP server. If the EmitDNS= option is enabled but no servers configured, the servers are automatically propagated from an \"uplink\" interface that has appropriate servers set. The \"uplink\" interface is determined by the default route of the system with the highest priority. Note that this information is acquired at the time the lease is handed out, and does not take uplink interfaces into account that acquire DNS server information at a later point. If no suitable uplink interface is found the DNS server data from '/etc/resolv.conf' is used. Also, note that the leases are not refreshed if the uplink network configuration changes. To ensure clients regularly acquire the most current uplink DNS server information, it is thus advisable to shorten the DHCP lease time via MaxLeaseTimeSec= described above. This setting can be specified multiple times. If an empty string is specified, then all DNS servers specified earlier are cleared."
              },
              "DNS": {
                "allOf": [
                  {
                    "$ref": "#/definitions/ip_address"
                  }
                ],
                "description": "A DNS server address, which must be in the format described in inet_pton3. This option may be specified more than once. Each address can optionally take a port number separated with ':', a network interface name or index separated with '%', and a Server Name Indication (SNI) separated with '#'. When IPv6 address is specified with a port number, then the address must be in the square brackets. That is, the acceptable full formats are '111.222.333.444:9953%ifname#example.com' for IPv4 and '[1111:2222::3333]:9953%ifname#example.com' for IPv6. If an empty string is assigned, then the all previous assignments are cleared. This setting is read by systemd-resolved.service8."
              },
              "EmitNTP": {
                "type": "boolean",
                "description": "Similar to the EmitDNS= and DNS= settings described above, these settings configure whether and what server information for the indicate protocol shall be emitted as part of the DHCP lease. The same syntax, propagation semantics and defaults apply as for EmitDNS= and DNS=."
              },
              "NTP": {
                "allOf": [
                  {
                    "$ref": "#/definitions/ip_address"
                  }
                ],
                "description": "An NTP server address (either an IP address, or a hostname). This option may be specified more than once. This setting is read by systemd-timesyncd.service8."
              },
              "EmitSIP": {
                "type": "boolean"
              },
              "SIP": {
                "type": "string"
              },
              "EmitRouter": {
                "type": "boolean",
                "default": true,
                "description": "The EmitRouter= setting takes a boolean value, and configures whether the DHCP lease should contain the router option. The Router= setting takes an IPv4 address, and configures the router address to be emitted. When the Router= setting is not specified, then the server address will be used for the router option. When the EmitRouter= setting is disabled, the Router= setting will be ignored. The EmitRouter= setting defaults to true, and the Router= setting defaults to unset."
              },
              "EmitTimezone": {
                "type": "boolean",
                "default": true,
                "description": "Configures whether the DHCP leases handed out to clients shall contain timezone information. Defaults to 'yes'. The Timezone= setting takes a timezone string (such as 'Europe/Berlin' or 'UTC') to pass to clients. If no explicit timezone is set, the system timezone of the local host is propagated, as determined by the '/etc/localtime' symlink."
              },
              "Timezone": {
                "type": "string"
              },
              "PoolOffset": {
                "type": "integer",
                "minimum": 0,
                "description": "Configures the pool of addresses to hand out. The pool is a contiguous sequence of IP addresses in the subnet configured for the server address, which does not include the subnet nor the broadcast address. PoolOffset= takes the offset of the pool from the start of subnet, or zero to use the default value. PoolSize= takes the number of IP addresses in the pool or zero to use the default value. By default, the pool starts at the first address after the subnet address and takes up the rest of the subnet, excluding the broadcast address. If the pool includes the server address (the default), this is reserved and not handed out to clients."
              },
              "PoolSize": {
                "type": "integer",
                "minimum": 0
              },
              "SendOption": {
                "type": "string",
                "enum": [
                  "ipv4address",
                  "ipv6address",
                  "string",
                  "uint16",
                  "uint32",
                  "uint8"
                ],
                "description": "Send a raw option with value via DHCPv4 server. Takes a DHCP option number, data type and data ('option:type:value'). The option number is an integer in the range 1...254. The type Special characters in the data string may be escaped using C-style escapes. This setting can be specified multiple times. If an empty string is specified, then all options specified earlier are cleared. Defaults to unset."
              }
            },
            "additionalProperties": false
          }
        },
        {
          "type": "object",
          "description": "[DHCPServer] section configuration",
          "properties": {
            "ServerAddress": {
              "allOf": [
                {
                  "$ref": "#/definitions/ip_address"
                }
              ],
              "description": "Specifies the server address for the DHCP server. Takes an IPv4 address with prefix length separated with a slash, e.g. '192.168.0.1/24'. Defaults to unset, and one of static IPv4 addresses configured in [Network] or [Address] section will be automatically selected. This setting may be useful when the interface on which the DHCP server is running has multiple static IPv4 addresses. This implies Address= in [Network] or [Address] section with the same address and prefix length. That is, [Network] DHCPServer=yes Address=192.168.0.1/24 Address=192.168.0.2/24 [DHCPServer] ServerAddress=192.168.0.1/24 or [Network] DHCPServer=yes [Address] Address=192.168.0.1/24 [Address] Address=192.168.0.2/24 [DHCPServer] ServerAddress=192.168.0.1/24 are equivalent to the following: [Network] DHCPServer=yes Address=192.168.0.2/24 [DHCPServer] ServerAddress=192.168.0.1/24 Since version 255, like the Address= setting in [Network] or [Address] section, this also supports a null address, e.g. '0.0.0.0/24', and an unused address will be automatically selected. For more details about the automatic address selection, see Address= setting in [Network] section in the above."
            },
            "UplinkInterface": {
              "type": "string",
              "default": ":auto",
              "description": "Specifies the name or the index of the uplink interface, or one of the special values ':none' and ':auto'. When emitting DNS, NTP, or SIP servers is enabled but no servers are specified, the servers configured in the uplink interface will be emitted. When ':auto', the link which has a default gateway with the highest priority will be automatically selected. When ':none', no uplink interface will be selected. Defaults to ':auto'."
            },
            "RelayTarget": {
              "allOf": [
                {
                  "$ref": "#/definitions/ip_address"
                }
              ],
              "description": "Takes an IPv4 address, which must be in the format described in inet_pton3. Turns this DHCP server into a DHCP relay agent. See RFC 1542. The address is the address of DHCP server or another relay agent to forward DHCP messages to and from."
            },
            "RelayAgentCircuitId": {
              "type": "string",
              "description": "Specifies value for Agent Circuit ID suboption of Relay Agent Information option. Takes a string, which must be in the format 'string:value', where 'value' should be replaced with the value of the suboption. Defaults to unset (means no Agent Circuit ID suboption is generated). Ignored if RelayTarget= is not specified."
            },
            "RelayAgentRemoteId": {
              "type": "string",
              "description": "Specifies value for Agent Remote ID suboption of Relay Agent Information option. Takes a string, which must be in the format 'string:value', where 'value' should be replaced with the value of the suboption. Defaults to unset (means no Agent Remote ID suboption is generated). Ignored if RelayTarget= is not specified."
            },
            "MaxLeaseTimeSec": {
              "$ref": "#/definitions/seconds"
            },
            "DefaultLeaseTimeSec": {
              "allOf": [
                {
                  "$ref": "#/definitions/seconds"
                }
              ],
              "description": "Control the default and maximum DHCP lease time to pass to clients. These settings take time values in seconds or another common time unit, depending on the suffix. The default lease time is used for clients that did not ask for a specific lease time. If a client asks for a lease time longer than the maximum lease time, it is automatically shortened to the specified time. The default lease time defaults to 1h, the maximum lease time to 12h. Shorter lease times are beneficial if the configuration data in DHCP leases changes frequently and clients shall learn the new settings with shorter latencies. Longer lease times reduce the generated DHCP network traffic.",
              "default": "1h"
            },
            "IPv6OnlyPreferredSec": {
              "type": "string",
              "description": "Takes a timespan. Controls the RFC 8925 IPv6-Only Preferred option. Specifies the DHCPv4 option to indicate that a host supports an IPv6-only mode and is willing to forgo obtaining an IPv4 address if the network provides IPv6 connectivity. Defaults to unset, and not send the option. The minimum allowed value is 300 seconds."
            },
            "EmitDNS": {
              "type": "boolean",
              "default": true,
              "description": "EmitDNS= takes a boolean. Configures whether the DHCP leases handed out to clients shall contain DNS server information. Defaults to 'yes'. The DNS servers to pass to clients may be configured with the DNS= option, which takes a list of IPv4 addresses, or special value '_server_address' which will be converted to the address used by the DHCP server. If the EmitDNS= option is enabled but no servers configured, the servers are automatically propagated from an \"uplink\" interface that has appropriate servers set. The \"uplink\" interface is determined by the default route of the system with the highest priority. Note that this information is acquired at the time the lease is handed out, and does not take uplink interfaces into account that acquire DNS server information at a later point. If no suitable uplink interface is found the DNS server data from '/etc/resolv.conf' is used. Also, note that the leases are not refreshed if the uplink network configuration changes. To ensure clients regularly acquire the most current uplink DNS server information, it is thus advisable to shorten the DHCP lease time via MaxLeaseTimeSec= described above. This setting can be specified multiple times. If an empty string is specified, then all DNS servers specified earlier are cleared."
            },
            "DNS": {
              "allOf": [
                {
                  "$ref": "#/definitions/ip_address"
                }
              ],
              "description": "A DNS server address, which must be in the format described in inet_pton3. This option may be specified more than once. Each address can optionally take a port number separated with ':', a network interface name or index separated with '%', and a Server Name Indication (SNI) separated with '#'. When IPv6 address is specified with a port number, then the address must be in the square brackets. That is, the acceptable full formats are '111.222.333.444:9953%ifname#example.com' for IPv4 and '[1111:2222::3333]:9953%ifname#example.com' for IPv6. If an empty string is assigned, then the all previous assignments are cleared. This setting is read by systemd-resolved.service8."
            },
            "EmitNTP": {
              "type": "boolean",
              "description": "Similar to the EmitDNS= and DNS= settings described above, these settings configure whether and what server information for the indicate protocol shall be emitted as part of the DHCP lease. The same syntax, propagation semantics and defaults apply as for EmitDNS= and DNS=."
            },
            "NTP": {
              "allOf": [
                {
                  "$ref": "#/definitions/ip_address"
                }
              ],
              "description": "An NTP server address (either an IP address, or a hostname). This option may be specified more than once. This setting is read by systemd-timesyncd.service8."
            },
            "EmitSIP": {
              "type": "boolean"
            },
            "SIP": {
              "type": "string"
            },
            "EmitPOP3": {
              "type": "boolean"
            },
            "POP3": {
              "type": "string"
            },
            "EmitSMTP": {
              "type": "boolean"
            },
            "SMTP": {
              "type": "string"
            },
            "EmitLPR": {
              "type": "boolean"
            },
            "LPR": {
              "type": "string"
            },
            "EmitRouter": {
              "type": "boolean",
              "default": true,
              "description": "The EmitRouter= setting takes a boolean value, and configures whether the DHCP lease should contain the router option. The Router= setting takes an IPv4 address, and configures the router address to be emitted. When the Router= setting is not specified, then the server address will be used for the router option. When the EmitRouter= setting is disabled, the Router= setting will be ignored. The EmitRouter= setting defaults to true, and the Router= setting defaults to unset."
            },
            "Router": {
              "$ref": "#/definitions/ip_address"
            },
            "EmitTimezone": {
              "type": "boolean",
              "default": true,
              "description": "Configures whether the DHCP leases handed out to clients shall contain timezone information. Defaults to 'yes'. The Timezone= setting takes a timezone string (such as 'Europe/Berlin' or 'UTC') to pass to clients. If no explicit timezone is set, the system timezone of the local host is propagated, as determined by the '/etc/localtime' symlink."
            },
            "Timezone": {
              "type": "string"
            },
            "PoolOffset": {
              "type": "string",
              "description": "Configures the pool of addresses to hand out. The pool is a contiguous sequence of IP addresses in the subnet configured for the server address, which does not include the subnet nor the broadcast address. PoolOffset= takes the offset of the pool from the start of subnet, or zero to use the default value. PoolSize= takes the number of IP addresses in the pool or zero to use the default value. By default, the pool starts at the first address after the subnet address and takes up the rest of the subnet, excluding the broadcast address. If the pool includes the server address (the default), this is reserved and not handed out to clients."
            },
            "PoolSize": {
              "type": "string"
            },
            "SendVendorOption": {
              "type": "string",
              "enum": [
                "ipv4address",
                "string",
                "uint16",
                "uint32",
                "uint8"
              ],
              "description": "Send a vendor option with value via DHCPv4 server. Takes a DHCP option number, data type and data ('option:type:value'). The option number is an integer in the range 1...254. The type Special characters in the data string may be escaped using C-style escapes. This setting can be specified multiple times. If an empty string is specified, then all options specified earlier are cleared. Defaults to unset."
            },
            "SendOption": {
              "type": "string",
              "enum": [
                "ipv4address",
                "ipv6address",
                "string",
                "uint16",
                "uint32",
                "uint8"
              ],
              "description": "Send a raw option with value via DHCPv4 server. Takes a DHCP option number, data type and data ('option:type:value'). The option number is an integer in the range 1...254. The type Special characters in the data string may be escaped using C-style escapes. This setting can be specified multiple times. If an empty string is specified, then all options specified earlier are cleared. Defaults to unset."
            },
            "BindToInterface": {
              "type": "boolean",
              "default": true,
              "description": "When 'yes', DHCP server socket will be bound to its network interface and all socket communication will be restricted to this interface. Defaults to 'yes', except if RelayTarget= is used (see below), in which case it defaults to 'no'."
            },
            "BootServerAddress": {
              "allOf": [
                {
                  "$ref": "#/definitions/ip_address"
                }
              ],
              "description": "Takes an IPv4 address of the boot server used by e.g. PXE boot systems. When specified, this address is sent in the 'siaddr' field of the DHCP message header. See RFC 2131 for more details. Defaults to unset."
            },
            "BootServerName": {
              "type": "string",
              "description": "Takes a name of the boot server used by e.g. PXE boot systems. When specified, this name is sent in the DHCP option 66 (\"TFTP server name\"). See RFC 2132 for more details. Defaults to unset. Note that typically setting one of BootServerName= or BootServerAddress= is sufficient, but both can be set too, if desired."
            },
            "BootFilename": {
              "allOf": [
                {
                  "$ref": "#/definitions/filename"
                }
              ],
              "description": "or URL to a file loaded by e.g. a PXE boot loader. When specified, this path is sent in the DHCP option 67 (\"Bootfile name\"). See RFC 2132 for more details. Defaults to unset."
            },
            "RapidCommit": {
              "type": "boolean",
              "default": true,
              "description": "When true, the server supports RFC 4039. When a client sends a DHCPDISCOVER message with the Rapid Commit option to the server, then the server will reply with a DHCPACK message to the client, instead of DHCPOFFER. Defaults to true."
            },
            "PersistLeases": {
              "type": "boolean",
              "default": true,
              "description": "When true, the DHCP server will load and save leases in the persistent storage. When false, the DHCP server will neither load nor save leases in the persistent storage. Hence, bound leases will be lost when the interface is reconfigured e.g. by networkctl reconfigure, or systemd-networkd.service8 is restarted. That may cause address conflict on the network. So, please take an extra care when disable this setting. When unspecified, the value specified in the same setting in networkd.conf5, which defaults to 'yes', will be used."
            }
          },
          "additionalProperties": false
        }
      ],
      "description": "[DHCPServer] configuration (Can be repeated)",
      "title": "DHCP Server",
      "examples": [
        "yes",
        "no"
      ]
    },
    "Bridge": {
      "oneOf": [
        {
          "type": "array",
          "items": {
            "type": "object",
            "description": "[Bridge] section configuration",
            "properties": {
              "Cost": {
                "type": "integer",
                "minimum": 1,
                "maximum": 65535,
                "description": "Sets the \"cost\" of sending packets of this interface. Each port in a bridge may have a different speed and the cost is used to decide which link to use. Faster interfaces should have lower costs. It is an integer value between 1 and 65535."
              },
              "UseBPDU": {
                "type": "boolean",
                "description": "Configures whether STP Bridge Protocol Data Units will be processed by the bridge port. When unset, the kernel's default will be used."
              },
              "HairPin": {
                "type": "boolean",
                "description": "Configures whether traffic may be sent back out of the port on which it was received. When this flag is false, then the bridge will not forward traffic back out of the receiving port. When unset, the kernel's default will be used."
              },
              "FastLeave": {
                "type": "boolean",
                "description": "This flag allows the bridge to immediately stop multicast traffic on a port that receives an IGMP Leave message. It is only used with IGMP snooping if enabled on the bridge. When unset, the kernel's default will be used."
              },
              "AllowPortToBeRoot": {
                "type": "boolean",
                "description": "Configures whether a given port is allowed to become a root port. Only used when STP is enabled on the bridge. When unset, the kernel's default will be used."
              },
              "UnicastFlood": {
                "type": "boolean",
                "description": "Controls whether the bridge should flood traffic for which an FDB entry is missing and the destination is unknown through this port. When unset, the kernel's default will be used."
              },
              "MulticastFlood": {
                "type": "boolean",
                "description": "Controls whether the bridge should flood traffic for which an MDB entry is missing and the destination is unknown through this port. When unset, the kernel's default will be used."
              },
              "MulticastToUnicast": {
                "type": "boolean",
                "description": "Multicast to unicast works on top of the multicast snooping feature of the bridge. Which means unicast copies are only delivered to hosts which are interested in it. When unset, the kernel's default will be used."
              },
              "NeighborSuppression": {
                "type": "boolean",
                "description": "Configures whether ARP and ND neighbor suppression is enabled for this port. When unset, the kernel's default will be used."
              },
              "Learning": {
                "type": "boolean",
                "description": "Configures whether MAC address learning is enabled for this port. When unset, the kernel's default will be used."
              },
              "ProxyARP": {
                "type": "boolean",
                "description": "Configures whether proxy ARP to be enabled on this port. When unset, the kernel's default will be used."
              },
              "ProxyARPWiFi": {
                "type": "boolean",
                "description": "Configures whether proxy ARP to be enabled on this port which meets extended requirements by IEEE 802.11 and Hotspot 2.0 specifications. When unset, the kernel's default will be used."
              },
              "Priority": {
                "type": "integer",
                "minimum": 0,
                "maximum": 63,
                "description": "Sets the \"priority\" of sending packets on this interface. Each port in a bridge may have a different priority which is used to decide which link to use. Lower value means higher priority. It is an integer value between 0 to 63. systemd-networkd does not set any default, meaning the kernel default value of 32 is used."
              },
              "MulticastRouter": {
                "type": "string",
                "enum": [
                  "no",
                  "permanent",
                  "query",
                  "temporary"
                ],
                "description": "Configures this port for having multicast routers attached. A port with a multicast router will receive all multicast traffic. When unset, the kernel's default will be used."
              }
            },
            "additionalProperties": false
          }
        },
        {
          "type": "object",
          "description": "[Bridge] section configuration",
          "properties": {
            "Cost": {
              "type": "integer",
              "minimum": 1,
              "maximum": 65535,
              "description": "Sets the \"cost\" of sending packets of this interface. Each port in a bridge may have a different speed and the cost is used to decide which link to use. Faster interfaces should have lower costs. It is an integer value between 1 and 65535."
            },
            "UseBPDU": {
              "type": "boolean",
              "description": "Configures whether STP Bridge Protocol Data Units will be processed by the bridge port. When unset, the kernel's default will be used."
            },
            "HairPin": {
              "type": "boolean",
              "description": "Configures whether traffic may be sent back out of the port on which it was received. When this flag is false, then the bridge will not forward traffic back out of the receiving port. When unset, the kernel's default will be used."
            },
            "Isolated": {
              "type": "boolean",
              "description": "Configures whether this port is isolated or not. Within a bridge, isolated ports can only communicate with non-isolated ports. When set to true, this port can only communicate with other ports whose Isolated setting is false. When set to false, this port can communicate with any other ports. When unset, the kernel's default will be used."
            },
            "FastLeave": {
              "type": "boolean",
              "description": "This flag allows the bridge to immediately stop multicast traffic on a port that receives an IGMP Leave message. It is only used with IGMP snooping if enabled on the bridge. When unset, the kernel's default will be used."
            },
            "AllowPortToBeRoot": {
              "type": "boolean",
              "description": "Configures whether a given port is allowed to become a root port. Only used when STP is enabled on the bridge. When unset, the kernel's default will be used."
            },
            "UnicastFlood": {
              "type": "boolean",
              "description": "Controls whether the bridge should flood traffic for which an FDB entry is missing and the destination is unknown through this port. When unset, the kernel's default will be used."
            },
            "MulticastFlood": {
              "type": "boolean",
              "description": "Controls whether the bridge should flood traffic for which an MDB entry is missing and the destination is unknown through this port. When unset, the kernel's default will be used."
            },
            "MulticastToUnicast": {
              "type": "boolean",
              "description": "Multicast to unicast works on top of the multicast snooping feature of the bridge. Which means unicast copies are only delivered to hosts which are interested in it. When unset, the kernel's default will be used."
            },
            "NeighborSuppression": {
              "type": "boolean",
              "description": "Configures whether ARP and ND neighbor suppression is enabled for this port. When unset, the kernel's default will be used."
            },
            "Learning": {
              "type": "boolean",
              "description": "Configures whether MAC address learning is enabled for this port. When unset, the kernel's default will be used."
            },
            "ProxyARP": {
              "type": "boolean",
              "description": "Configures whether proxy ARP to be enabled on this port. When unset, the kernel's default will be used."
            },
            "ProxyARPWiFi": {
              "type": "boolean",
              "description": "Configures whether proxy ARP to be enabled on this port which meets extended requirements by IEEE 802.11 and Hotspot 2.0 specifications. When unset, the kernel's default will be used."
            },
            "Priority": {
              "type": "integer",
              "minimum": 0,
              "maximum": 63,
              "description": "Sets the \"priority\" of sending packets on this interface. Each port in a bridge may have a different priority which is used to decide which link to use. Lower value means higher priority. It is an integer value between 0 to 63. systemd-networkd does not set any default, meaning the kernel default value of 32 is used."
            },
            "MulticastRouter": {
              "type": "string",
              "enum": [
                "no",
                "permanent",
                "query",
                "temporary"
              ],
              "description": "Configures this port for having multicast routers attached. A port with a multicast router will receive all multicast traffic. When unset, the kernel's default will be used."
            }
          },
          "additionalProperties": false
        }
      ],
      "description": "[Bridge] configuration (Can be repeated)",
      "title": "Bridge"
    },
    "BridgeFDB": {
      "oneOf": [
        {
          "type": "array",
          "items": {
            "type": "object",
            "description": "[BridgeFDB] section configuration",
            "properties": {
              "MACAddress": {
                "allOf": [
                  {
                    "$ref": "#/definitions/mac_address"
                  }
                ],
                "description": "As in the [Network] section. This key is mandatory.",
                "_mandatory": true
              },
              "VLANId": {
                "allOf": [
                  {
                    "$ref": "#/definitions/vlan_id"
                  }
                ],
                "description": "The VLAN ID for the new static MAC table entry. If omitted, no VLAN ID information is appended to the new static MAC table entry."
              },
              "Destination": {
                "allOf": [
                  {
                    "$ref": "#/definitions/ip_prefix"
                  }
                ],
                "description": "Takes an IP address of the destination VXLAN tunnel endpoint."
              },
              "VNI": {
                "type": "integer",
                "minimum": 1,
                "maximum": 16777215,
                "description": "The VXLAN Network Identifier (or VXLAN Segment ID) to use to connect to the remote VXLAN tunnel endpoint. Defaults to unset."
              },
              "AssociatedWith": {
                "type": "string",
                "enum": [
                  "master",
                  "router",
                  "self",
                  "use"
                ],
                "default": "self",
                "description": "Specifies where the address is associated with. 'use' means the address is in use. User space can use this option to indicate to the kernel that the fdb entry is in use. 'self' means the address is associated with the port drivers fdb. Usually hardware. 'master' means the address is associated with master devices fdb. 'router' means the destination address is associated with a router. Note that it's valid if the referenced device is a VXLAN type device and has route shortcircuit enabled. Defaults to 'self'."
              }
            },
            "additionalProperties": false
          }
        },
        {
          "type": "object",
          "description": "[BridgeFDB] section configuration",
          "properties": {
            "MACAddress": {
              "allOf": [
                {
                  "$ref": "#/definitions/mac_address"
                }
              ],
              "description": "As in the [Network] section. This key is mandatory.",
              "_mandatory": true
            },
            "VLANId": {
              "allOf": [
                {
                  "$ref": "#/definitions/vlan_id"
                }
              ],
              "description": "The VLAN ID for the new static MAC table entry. If omitted, no VLAN ID information is appended to the new static MAC table entry."
            },
            "Destination": {
              "allOf": [
                {
                  "$ref": "#/definitions/ip_prefix"
                }
              ],
              "description": "Takes an IP address of the destination VXLAN tunnel endpoint."
            },
            "VNI": {
              "type": "integer",
              "minimum": 1,
              "maximum": 16777215,
              "description": "The VXLAN Network Identifier (or VXLAN Segment ID) to use to connect to the remote VXLAN tunnel endpoint. Defaults to unset."
            },
            "AssociatedWith": {
              "type": "string",
              "enum": [
                "master",
                "router",
                "self",
                "use"
              ],
              "default": "self",
              "description": "Specifies where the address is associated with. 'use' means the address is in use. User space can use this option to indicate to the kernel that the fdb entry is in use. 'self' means the address is associated with the port drivers fdb. Usually hardware. 'master' means the address is associated with master devices fdb. 'router' means the destination address is associated with a router. Note that it's valid if the referenced device is a VXLAN type device and has route shortcircuit enabled. Defaults to 'self'."
            },
            "OutgoingInterface": {
              "oneOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "string"
                }
              ],
              "description": "Specifies the name or index of the outgoing interface for the VXLAN device driver to reach the remote VXLAN tunnel endpoint. Defaults to unset."
            }
          },
          "additionalProperties": false
        }
      ],
      "description": "[BridgeFDB] configuration (Can be repeated)",
      "title": "Bridge FDB"
    },
    "BridgeVLAN": {
      "oneOf": [
        {
          "type": "array",
          "items": {
            "type": "object",
            "description": "[BridgeVLAN] section configuration",
            "properties": {
              "PVID": {
                "oneOf": [
                  {
                    "allOf": [
                      {
                        "$ref": "#/definitions/vlan_id"
                      }
                    ],
                    "minimum": 1
                  },
                  {
                    "type": "boolean",
                    "enum": [
                      false
                    ]
                  }
                ],
                "description": "The port VLAN ID specified here is assigned to all untagged frames at ingress. Takes an VLAN ID or negative boolean value (e.g. 'no'). When false, the currently assigned port VLAN ID will be dropped. Configuring PVID= implicates the use of VLAN= setting in the above and will enable the VLAN ID for ingress as well. Defaults to unset, and will keep the assigned port VLAN ID if exists."
              },
              "VLAN": {
                "oneOf": [
                  {
                    "allOf": [
                      {
                        "$ref": "#/definitions/vlan_id"
                      }
                    ],
                    "minimum": 1
                  },
                  {
                    "type": "string",
                    "pattern": "^[0-9]+-[0-9]+$"
                  }
                ],
                "description": "The VLAN ID allowed on the port. This can be either a single ID or a range M-N. This setting can be specified multiple times. If an empty string is assigned, then the all previous assignments are cleared."
              },
              "EgressUntagged": {
                "oneOf": [
                  {
                    "allOf": [
                      {
                        "$ref": "#/definitions/vlan_id"
                      }
                    ],
                    "minimum": 1
                  },
                  {
                    "type": "string",
                    "pattern": "^[0-9]+-[0-9]+$"
                  }
                ],
                "description": "The VLAN ID specified here will be used to untag frames on egress. Configuring EgressUntagged= implicates the use of VLAN= above and will enable the VLAN ID for ingress as well. This can be either a single ID or a range M-N. This setting can be specified multiple times. If an empty string is assigned, then the all previous assignments are cleared."
              }
            },
            "additionalProperties": false
          }
        },
        {
          "type": "object",
          "description": "[BridgeVLAN] section configuration",
          "properties": {
            "PVID": {
              "oneOf": [
                {
                  "allOf": [
                    {
                      "$ref": "#/definitions/vlan_id"
                    }
                  ],
                  "minimum": 1
                },
                {
                  "type": "boolean",
                  "enum": [
                    false
                  ]
                }
              ],
              "description": "The port VLAN ID specified here is assigned to all untagged frames at ingress. Takes an VLAN ID or negative boolean value (e.g. 'no'). When false, the currently assigned port VLAN ID will be dropped. Configuring PVID= implicates the use of VLAN= setting in the above and will enable the VLAN ID for ingress as well. Defaults to unset, and will keep the assigned port VLAN ID if exists."
            },
            "VLAN": {
              "oneOf": [
                {
                  "allOf": [
                    {
                      "$ref": "#/definitions/vlan_id"
                    }
                  ],
                  "minimum": 1
                },
                {
                  "type": "string",
                  "pattern": "^[0-9]+-[0-9]+$"
                }
              ],
              "description": "The VLAN ID allowed on the port. This can be either a single ID or a range M-N. This setting can be specified multiple times. If an empty string is assigned, then the all previous assignments are cleared."
            },
            "EgressUntagged": {
              "oneOf": [
                {
                  "allOf": [
                    {
                      "$ref": "#/definitions/vlan_id"
                    }
                  ],
                  "minimum": 1
                },
                {
                  "type": "string",
                  "pattern": "^[0-9]+-[0-9]+$"
                }
              ],
              "description": "The VLAN ID specified here will be used to untag frames on egress. Configuring EgressUntagged= implicates the use of VLAN= above and will enable the VLAN ID for ingress as well. This can be either a single ID or a range M-N. This setting can be specified multiple times. If an empty string is assigned, then the all previous assignments are cleared."
            }
          },
          "additionalProperties": false
        }
      ],
      "description": "[BridgeVLAN] configuration (Can be repeated)",
      "title": "Bridge VLAN"
    },
    "IPv6Prefix": {
      "oneOf": [
        {
          "type": "array",
          "items": {
            "type": "object",
            "description": "[IPv6Prefix] section configuration",
            "properties": {
              "Prefix": {
                "type": "string",
                "description": "The IPv6 prefix that is to be distributed to hosts. Similarly to configuring static IPv6 addresses, the setting is configured as an IPv6 prefix and its prefix length, separated by a '/' character. Use multiple [IPv6Prefix] sections to configure multiple IPv6 prefixes since prefix lifetimes, address autoconfiguration and onlink status may differ from one prefix to another."
              },
              "OnLink": {
                "type": "boolean",
                "default": false,
                "description": "If set to true, the kernel does not have to check if the gateway is reachable directly by the current machine (i.e., attached to the local network), so that we can insert the nexthop in the kernel table without it being complained about. Defaults to 'no'."
              },
              "AddressAutoconfiguration": {
                "type": "boolean",
                "default": true,
                "description": "to specify whether IPv6 addresses can be autoconfigured with this prefix and whether the prefix can be used for onlink determination. Both settings default to 'true' in order to ease configuration."
              },
              "ValidLifetimeSec": {
                "allOf": [
                  {
                    "$ref": "#/definitions/seconds"
                  }
                ]
              },
              "PreferredLifetimeSec": {
                "allOf": [
                  {
                    "$ref": "#/definitions/seconds"
                  }
                ],
                "description": "Preferred and valid lifetimes for the prefix measured in seconds. PreferredLifetimeSec= defaults to 1800 seconds (30 minutes) and ValidLifetimeSec= defaults to 3600 seconds (one hour).",
                "default": "1800"
              }
            },
            "additionalProperties": false
          }
        },
        {
          "type": "object",
          "description": "[IPv6Prefix] section configuration",
          "properties": {
            "Prefix": {
              "type": "string",
              "description": "The IPv6 prefix that is to be distributed to hosts. Similarly to configuring static IPv6 addresses, the setting is configured as an IPv6 prefix and its prefix length, separated by a '/' character. Use multiple [IPv6Prefix] sections to configure multiple IPv6 prefixes since prefix lifetimes, address autoconfiguration and onlink status may differ from one prefix to another."
            },
            "OnLink": {
              "type": "boolean",
              "default": false,
              "description": "If set to true, the kernel does not have to check if the gateway is reachable directly by the current machine (i.e., attached to the local network), so that we can insert the nexthop in the kernel table without it being complained about. Defaults to 'no'."
            },
            "AddressAutoconfiguration": {
              "type": "boolean",
              "default": true,
              "description": "to specify whether IPv6 addresses can be autoconfigured with this prefix and whether the prefix can be used for onlink determination. Both settings default to 'true' in order to ease configuration."
            },
            "ValidLifetimeSec": {
              "type": "string"
            },
            "PreferredLifetimeSec": {
              "allOf": [
                {
                  "$ref": "#/definitions/seconds"
                }
              ],
              "description": "Preferred and valid lifetimes for the prefix measured in seconds. PreferredLifetimeSec= defaults to 1800 seconds (30 minutes) and ValidLifetimeSec= defaults to 3600 seconds (one hour).",
              "default": "1800"
            },
            "Assign": {
              "type": "boolean",
              "default": false,
              "description": "When true, adds an address from the prefix. Default to false."
            },
            "RouteMetric": {
              "type": "integer",
              "minimum": 0,
              "maximum": 4294967295,
              "description": "The metric of the prefix route. Takes an unsigned integer in the range 0...4294967295. When unset or set to 0, the kernel's default value is used. This setting is ignored when Assign= is false."
            },
            "Token": {
              "type": "string",
              "description": "Specifies an optional address generation mode for assigning an address in each prefix. This accepts the same syntax as Token= in the [IPv6AcceptRA] section. If Assign= is set to false, then this setting will be ignored. Defaults to unset, which means the EUI-64 algorithm will be used."
            }
          },
          "additionalProperties": false
        }
      ],
      "description": "[IPv6Prefix] configuration (Can be repeated)",
      "title": "I Pv6 Prefix"
    },
    "IPv6RoutePrefix": {
      "oneOf": [
        {
          "type": "array",
          "items": {
            "type": "object",
            "description": "[IPv6RoutePrefix] section configuration",
            "properties": {
              "Route": {
                "type": "string",
                "description": "The IPv6 route that is to be distributed to hosts. Similarly to configuring static IPv6 routes, the setting is configured as an IPv6 prefix routes and its prefix route length, separated by a '/' character. Use multiple [IPv6RoutePrefix] sections to configure multiple IPv6 prefix routes."
              },
              "LifetimeSec": {
                "allOf": [
                  {
                    "$ref": "#/definitions/seconds"
                  }
                ],
                "description": "Lifetime for the route prefix measured in seconds. LifetimeSec= defaults to 3600 seconds (one hour).",
                "default": "3600"
              }
            },
            "additionalProperties": false
          }
        },
        {
          "type": "object",
          "description": "[IPv6RoutePrefix] section configuration",
          "properties": {
            "Route": {
              "type": "string",
              "description": "The IPv6 route that is to be distributed to hosts. Similarly to configuring static IPv6 routes, the setting is configured as an IPv6 prefix routes and its prefix route length, separated by a '/' character. Use multiple [IPv6RoutePrefix] sections to configure multiple IPv6 prefix routes."
            },
            "LifetimeSec": {
              "allOf": [
                {
                  "$ref": "#/definitions/seconds"
                }
              ],
              "description": "Lifetime for the route prefix measured in seconds. LifetimeSec= defaults to 3600 seconds (one hour).",
              "default": "3600"
            }
          },
          "additionalProperties": false
        }
      ],
      "description": "[IPv6RoutePrefix] configuration (Can be repeated)",
      "title": "I Pv6 Route Prefix"
    },
    "CAN": {
      "oneOf": [
        {
          "type": "array",
          "items": {
            "type": "object",
            "description": "[CAN] section configuration",
            "properties": {
              "BitRate": {
                "type": "integer",
                "minimum": 1,
                "maximum": 4294967295,
                "description": "The bitrate of CAN device in bits per second. The usual SI prefixes (K, M) with the base of 1000 can be used here."
              },
              "SamplePoint": {
                "type": "string",
                "description": "Optional sample point in percent with one decimal (e.g. '75%', '87.5%') or permille (e.g. '875'). This will be ignored when BitRate= is unspecified."
              },
              "RestartSec": {
                "allOf": [
                  {
                    "$ref": "#/definitions/seconds"
                  }
                ],
                "description": "Automatic restart delay time. If set to a non-zero value, a restart of the CAN controller will be triggered automatically in case of a bus-off condition after the specified delay time. Subsecond delays can be specified using decimals (e.g. '0.1s') or a 'ms' or 'us' postfix. Using 'infinity' or '0' will turn the automatic restart off. By default automatic restart is disabled."
              },
              "TripleSampling": {
                "type": "boolean",
                "description": "When 'yes', three samples (instead of one) are used to determine the value of a received bit by majority rule. When unset, the kernel's default will be used."
              }
            },
            "additionalProperties": false
          }
        },
        {
          "type": "object",
          "description": "[CAN] section configuration",
          "properties": {
            "BitRate": {
              "type": "integer",
              "minimum": 1,
              "maximum": 4294967295,
              "description": "The bitrate of CAN device in bits per second. The usual SI prefixes (K, M) with the base of 1000 can be used here."
            },
            "SamplePoint": {
              "type": "string",
              "description": "Optional sample point in percent with one decimal (e.g. '75%', '87.5%') or permille (e.g. '875'). This will be ignored when BitRate= is unspecified."
            },
            "TimeQuantaNSec": {
              "type": "string",
              "description": "Specifies the time quanta, propagation segment, phase buffer segment 1 and 2, and the synchronization jump width, which allow one to define the CAN bit-timing in a hardware independent format as proposed by the Bosch CAN 2.0 Specification. TimeQuantaNSec= takes a timespan in nanoseconds. PropagationSegment=, PhaseBufferSegment1=, PhaseBufferSegment2=, and SyncJumpWidth= take number of time quantum specified in TimeQuantaNSec= and must be an unsigned integer in the range 0...4294967295. These settings except for SyncJumpWidth= will be ignored when BitRate= is specified."
            },
            "PropagationSegment": {
              "type": "string"
            },
            "PhaseBufferSegment1": {
              "type": "string"
            },
            "PhaseBufferSegment2": {
              "type": "string"
            },
            "SyncJumpWidth": {
              "type": "integer",
              "minimum": 0,
              "maximum": 4294967295
            },
            "DataBitRate": {
              "type": "integer",
              "minimum": 1,
              "maximum": 4294967295,
              "description": "The bitrate and sample point for the data phase, if CAN-FD is used. These settings are analogous to the BitRate= and SamplePoint= keys."
            },
            "DataSamplePoint": {
              "type": "string"
            },
            "DataTimeQuantaNSec": {
              "type": "string",
              "description": "Specifies the time quanta, propagation segment, phase buffer segment 1 and 2, and the synchronization jump width for the data phase, if CAN-FD is used. These settings are analogous to the TimeQuantaNSec= or related settings."
            },
            "DataPropagationSegment": {
              "type": "string"
            },
            "DataPhaseBufferSegment1": {
              "type": "string"
            },
            "DataPhaseBufferSegment2": {
              "type": "string"
            },
            "DataSyncJumpWidth": {
              "type": "string"
            },
            "RestartSec": {
              "allOf": [
                {
                  "$ref": "#/definitions/seconds"
                }
              ],
              "description": "Automatic restart delay time. If set to a non-zero value, a restart of the CAN controller will be triggered automatically in case of a bus-off condition after the specified delay time. Subsecond delays can be specified using decimals (e.g. '0.1s') or a 'ms' or 'us' postfix. Using 'infinity' or '0' will turn the automatic restart off. By default automatic restart is disabled."
            },
            "Loopback": {
              "type": "boolean",
              "description": "When 'yes', loopback mode is enabled. When the loopback mode is enabled, the interface treats messages transmitted by itself as received messages. The loopback mode is important to debug CAN networks. When unset, the kernel's default will be used."
            },
            "ListenOnly": {
              "type": "boolean",
              "description": "When 'yes', listen-only mode is enabled. When the interface is in listen-only mode, the interface neither transmit CAN frames nor send ACK bit. Listen-only mode is important to debug CAN networks without interfering with the communication or acknowledge the CAN frame. When unset, the kernel's default will be used."
            },
            "TripleSampling": {
              "type": "boolean",
              "description": "When 'yes', three samples (instead of one) are used to determine the value of a received bit by majority rule. When unset, the kernel's default will be used."
            },
            "OneShot": {
              "type": "boolean",
              "description": "When 'yes', one-shot mode is enabled. When unset, the kernel's default will be used."
            },
            "BusErrorReporting": {
              "type": "boolean",
              "description": "When 'yes', reporting of CAN bus errors is activated (those include single bit, frame format, and bit stuffing errors, unable to send dominant bit, unable to send recessive bit, bus overload, active error announcement, error occurred on transmission). When unset, the kernel's default will be used. Note: in case of a CAN bus with a single CAN device, sending a CAN frame may result in a huge number of CAN bus errors."
            },
            "FDMode": {
              "type": "boolean",
              "description": "When 'yes', CAN-FD mode is enabled for the interface. Note, that a bitrate and optional sample point should also be set for the CAN-FD data phase using the DataBitRate= and DataSamplePoint= keys, or DataTimeQuanta= and related settings."
            },
            "FDNonISO": {
              "type": "boolean",
              "description": "When 'yes', non-ISO CAN-FD mode is enabled for the interface. When unset, the kernel's default will be used."
            },
            "ClassicDataLengthCode": {
              "type": "boolean",
              "description": "When 'yes', the interface will handle the 4bit data length code (DLC). When unset, the kernel's default will be used."
            },
            "Termination": {
              "oneOf": [
                {
                  "type": "boolean"
                },
                {
                  "allOf": [
                    {
                      "$ref": "#/definitions/uint16"
                    }
                  ]
                }
              ],
              "description": "or a termination resistor value in ohm in the range 0...65535. When 'yes', the termination resistor is set to 120 ohm. When 'no' or '0' is set, the termination resistor is disabled. When unset, the kernel's default will be used."
            },
            "PresumeAck": {
              "type": "boolean",
              "description": "When 'yes', the interface will ignore missing CAN ACKs. When unset, the kernel's default will be used."
            }
          },
          "additionalProperties": false
        }
      ],
      "description": "[CAN] configuration (Can be repeated)",
      "title": "CAN"
    },
    "IPv6PrefixDelegation": {
      "oneOf": [
        {
          "type": "array",
          "items": {
            "type": "object",
            "description": "[IPv6PrefixDelegation] section configuration",
            "properties": {
              "RouterLifetimeSec": {
                "allOf": [
                  {
                    "$ref": "#/definitions/seconds"
                  }
                ],
                "description": "Takes a timespan. Configures the IPv6 router lifetime in seconds. The value must be 0 seconds, or between 4 seconds and 9000 seconds. When set to 0, the host is not acting as a router. Defaults to 1800 seconds (30 minutes).",
                "default": "1800"
              },
              "Managed": {
                "type": "boolean",
                "default": false,
                "description": "Controls whether a DHCPv6 server is used to acquire IPv6 addresses on the network link when Managed= is set to 'true' or if only additional network information can be obtained via DHCPv6 for the network link when OtherInformation= is set to 'true'. Both settings default to 'false', which means that a DHCPv6 server is not being used."
              },
              "OtherInformation": {
                "type": "boolean"
              },
              "RouterPreference": {
                "type": "string",
                "enum": [
                  "default",
                  "high",
                  "low",
                  "medium",
                  "normal"
                ],
                "default": "medium",
                "description": "Configures IPv6 router preference if RouterLifetimeSec= is non-zero. Valid See RFC 4191 for details. Defaults to 'medium'."
              },
              "EmitDNS": {
                "type": "boolean",
                "default": true,
                "description": "EmitDNS= takes a boolean. Configures whether the DHCP leases handed out to clients shall contain DNS server information. Defaults to 'yes'. The DNS servers to pass to clients may be configured with the DNS= option, which takes a list of IPv4 addresses, or special value '_server_address' which will be converted to the address used by the DHCP server. If the EmitDNS= option is enabled but no servers configured, the servers are automatically propagated from an \"uplink\" interface that has appropriate servers set. The \"uplink\" interface is determined by the default route of the system with the highest priority. Note that this information is acquired at the time the lease is handed out, and does not take uplink interfaces into account that acquire DNS server information at a later point. If no suitable uplink interface is found the DNS server data from '/etc/resolv.conf' is used. Also, note that the leases are not refreshed if the uplink network configuration changes. To ensure clients regularly acquire the most current uplink DNS server information, it is thus advisable to shorten the DHCP lease time via MaxLeaseTimeSec= described above. This setting can be specified multiple times. If an empty string is specified, then all DNS servers specified earlier are cleared."
              },
              "DNS": {
                "allOf": [
                  {
                    "$ref": "#/definitions/ip_address"
                  }
                ],
                "description": "A DNS server address, which must be in the format described in inet_pton3. This option may be specified more than once. Each address can optionally take a port number separated with ':', a network interface name or index separated with '%', and a Server Name Indication (SNI) separated with '#'. When IPv6 address is specified with a port number, then the address must be in the square brackets. That is, the acceptable full formats are '111.222.333.444:9953%ifname#example.com' for IPv4 and '[1111:2222::3333]:9953%ifname#example.com' for IPv6. If an empty string is assigned, then the all previous assignments are cleared. This setting is read by systemd-resolved.service8."
              },
              "EmitDomains": {
                "type": "boolean",
                "default": true,
                "description": "A list of DNS search domains distributed via Router Advertisement messages when EmitDomains= is true. If Domains= is empty, DNS search domains are read from the [Network] section. If the [Network] section does not contain any DNS search domains either, DNS search domains from the uplink interface specified in UplinkInterface= will be used. When EmitDomains= is false, no DNS search domain information is sent in Router Advertisement messages. EmitDomains= defaults to true."
              },
              "Domains": {
                "type": "string",
                "description": "A whitespace-separated list of domains which should be resolved using the DNS servers on this link. Each item in the list should be a domain name, optionally prefixed with a tilde ('~'). The domains with the prefix are called \"routing-only domains\". The domains without the prefix are called \"search domains\" and are first used as search suffixes for extending single-label hostnames (hostnames containing no dots) to become fully qualified domain names (FQDNs). If a single-label hostname is resolved on this interface, each of the specified search domains are appended to it in turn, converting it into a fully qualified domain name, until one of them may be successfully resolved. Both \"search\" and \"routing-only\" domains are used for routing of DNS queries: look-ups for hostnames ending in those domains (hence also single label names, if any \"search domains\" are listed), are routed to the DNS servers configured for this interface. The domain routing logic is particularly useful on multi-homed hosts with DNS servers serving particular private DNS zones on each interface. The \"routing-only\" domain '~.' (the tilde indicating definition of a routing domain, the dot referring to the DNS root domain which is the implied suffix of all valid DNS names) has special effect. It causes all DNS traffic which does not match another configured domain routing entry to be routed to DNS servers specified for this interface. This setting is useful to prefer a certain set of DNS servers if a link on which they are connected is available. This setting is read by systemd-resolved.service8. \"Search domains\" correspond to the domain and search entries in resolv.conf5. Domain name routing has no equivalent in the traditional glibc API, which has no concept of domain name servers limited to a specific link."
              },
              "DNSLifetimeSec": {
                "allOf": [
                  {
                    "$ref": "#/definitions/seconds"
                  }
                ],
                "description": "Lifetime in seconds for the DNS server addresses listed in DNS= and search domains listed in Domains=. Defaults to 3600 seconds (one hour).",
                "default": "3600"
              }
            },
            "additionalProperties": false
          }
        },
        {
          "type": "object",
          "description": "[IPv6PrefixDelegation] section configuration",
          "properties": {
            "RouterLifetimeSec": {
              "allOf": [
                {
                  "$ref": "#/definitions/seconds"
                }
              ],
              "description": "Takes a timespan. Configures the IPv6 router lifetime in seconds. The value must be 0 seconds, or between 4 seconds and 9000 seconds. When set to 0, the host is not acting as a router. Defaults to 1800 seconds (30 minutes).",
              "default": "1800"
            },
            "Managed": {
              "type": "boolean",
              "default": false,
              "description": "Controls whether a DHCPv6 server is used to acquire IPv6 addresses on the network link when Managed= is set to 'true' or if only additional network information can be obtained via DHCPv6 for the network link when OtherInformation= is set to 'true'. Both settings default to 'false', which means that a DHCPv6 server is not being used."
            },
            "OtherInformation": {
              "type": "boolean"
            },
            "RouterPreference": {
              "type": "string",
              "enum": [
                "default",
                "high",
                "low",
                "medium",
                "normal"
              ],
              "default": "medium",
              "description": "Configures IPv6 router preference if RouterLifetimeSec= is non-zero. Valid See RFC 4191 for details. Defaults to 'medium'."
            },
            "EmitDNS": {
              "type": "boolean",
              "default": true,
              "description": "EmitDNS= takes a boolean. Configures whether the DHCP leases handed out to clients shall contain DNS server information. Defaults to 'yes'. The DNS servers to pass to clients may be configured with the DNS= option, which takes a list of IPv4 addresses, or special value '_server_address' which will be converted to the address used by the DHCP server. If the EmitDNS= option is enabled but no servers configured, the servers are automatically propagated from an \"uplink\" interface that has appropriate servers set. The \"uplink\" interface is determined by the default route of the system with the highest priority. Note that this information is acquired at the time the lease is handed out, and does not take uplink interfaces into account that acquire DNS server information at a later point. If no suitable uplink interface is found the DNS server data from '/etc/resolv.conf' is used. Also, note that the leases are not refreshed if the uplink network configuration changes. To ensure clients regularly acquire the most current uplink DNS server information, it is thus advisable to shorten the DHCP lease time via MaxLeaseTimeSec= described above. This setting can be specified multiple times. If an empty string is specified, then all DNS servers specified earlier are cleared."
            },
            "DNS": {
              "allOf": [
                {
                  "$ref": "#/definitions/ip_address"
                }
              ],
              "description": "A DNS server address, which must be in the format described in inet_pton3. This option may be specified more than once. Each address can optionally take a port number separated with ':', a network interface name or index separated with '%', and a Server Name Indication (SNI) separated with '#'. When IPv6 address is specified with a port number, then the address must be in the square brackets. That is, the acceptable full formats are '111.222.333.444:9953%ifname#example.com' for IPv4 and '[1111:2222::3333]:9953%ifname#example.com' for IPv6. If an empty string is assigned, then the all previous assignments are cleared. This setting is read by systemd-resolved.service8."
            },
            "EmitDomains": {
              "type": "boolean",
              "default": true,
              "description": "A list of DNS search domains distributed via Router Advertisement messages when EmitDomains= is true. If Domains= is empty, DNS search domains are read from the [Network] section. If the [Network] section does not contain any DNS search domains either, DNS search domains from the uplink interface specified in UplinkInterface= will be used. When EmitDomains= is false, no DNS search domain information is sent in Router Advertisement messages. EmitDomains= defaults to true."
            },
            "Domains": {
              "type": "string",
              "description": "A whitespace-separated list of domains which should be resolved using the DNS servers on this link. Each item in the list should be a domain name, optionally prefixed with a tilde ('~'). The domains with the prefix are called \"routing-only domains\". The domains without the prefix are called \"search domains\" and are first used as search suffixes for extending single-label hostnames (hostnames containing no dots) to become fully qualified domain names (FQDNs). If a single-label hostname is resolved on this interface, each of the specified search domains are appended to it in turn, converting it into a fully qualified domain name, until one of them may be successfully resolved. Both \"search\" and \"routing-only\" domains are used for routing of DNS queries: look-ups for hostnames ending in those domains (hence also single label names, if any \"search domains\" are listed), are routed to the DNS servers configured for this interface. The domain routing logic is particularly useful on multi-homed hosts with DNS servers serving particular private DNS zones on each interface. The \"routing-only\" domain '~.' (the tilde indicating definition of a routing domain, the dot referring to the DNS root domain which is the implied suffix of all valid DNS names) has special effect. It causes all DNS traffic which does not match another configured domain routing entry to be routed to DNS servers specified for this interface. This setting is useful to prefer a certain set of DNS servers if a link on which they are connected is available. This setting is read by systemd-resolved.service8. \"Search domains\" correspond to the domain and search entries in resolv.conf5. Domain name routing has no equivalent in the traditional glibc API, which has no concept of domain name servers limited to a specific link."
            },
            "DNSLifetimeSec": {
              "allOf": [
                {
                  "$ref": "#/definitions/seconds"
                }
              ],
              "description": "Lifetime in seconds for the DNS server addresses listed in DNS= and search domains listed in Domains=. Defaults to 3600 seconds (one hour).",
              "default": "3600"
            }
          },
          "additionalProperties": false
        }
      ],
      "description": "[IPv6PrefixDelegation] configuration (Can be repeated)",
      "title": "I Pv6 Prefix Delegation"
    },
    "DHCP": {
      "oneOf": [
        {
          "type": "array",
          "items": {
            "type": "object",
            "description": "[DHCP] section configuration",
            "properties": {
              "ClientIdentifier": {
                "type": "string",
                "enum": [
                  "duid",
                  "mac"
                ],
                "default": "duid",
                "description": "The DHCPv4 client identifier to use. If set to 'mac', the MAC address of the link is used. If set to 'duid', an RFC4361-compliant Client ID, which is the combination of IAID and DUID, is used. IAID can be configured by IAID=. DUID can be configured by DUIDType= and DUIDRawData=. Defaults to 'duid'."
              },
              "UseDNS": {
                "type": "boolean",
                "description": "When true (the default), the DNS servers received from the DHCP server will be used. This corresponds to the 'nameserver' option in resolv.conf5."
              },
              "UseNTP": {
                "type": "boolean",
                "description": "When true (the default), the NTP servers received from the DHCP server will be used by 'systemd-timesyncd.service'."
              },
              "UseMTU": {
                "type": "boolean",
                "default": false,
                "description": "When true, the interface maximum transmission unit from the DHCP server will be used on the current link. If MTUBytes= is set, then this setting is ignored. Defaults to false. Note, some drivers will reset the interfaces if the MTU is changed. For such interfaces, please try to use IgnoreCarrierLoss= with a short timespan, e.g. '3 seconds'."
              },
              "UseHostname": {
                "type": "boolean",
                "description": "When true (the default), the hostname received from the DHCP server will be set as the transient hostname of the system."
              },
              "UseDomains": {
                "oneOf": [
                  {
                    "type": "boolean"
                  },
                  {
                    "type": "string",
                    "enum": [
                      "route"
                    ]
                  }
                ],
                "description": "Specifies the protocol-independent default value for the same settings in [IPv6AcceptRA], [DHCPv4], and [DHCPv6] sections below. Takes a boolean, or the special value 'route'. See also the same setting in [DHCPv4] below. Defaults to unset."
              },
              "UseDomainName": {
                "type": "string"
              },
              "UseRoutes": {
                "type": "boolean",
                "description": "When true (the default), the static routes will be requested from the DHCP server and added to the routing table with a metric of 1024, and a scope of 'global', 'link' or 'host', depending on the route's destination and gateway. If the destination is on the local host, e.g., 127.x.x.x, or the same as the link's own address, the scope will be set to 'host'. Otherwise if the gateway is null (a direct route), a 'link' scope will be used. For anything else, scope defaults to 'global'."
              },
              "Anonymize": {
                "type": "boolean",
                "default": false,
                "description": "When true, the options sent to the DHCP server will follow the RFC 7844 (Anonymity Profiles for DHCP Clients) to minimize disclosure of identifying information. Defaults to false. This option should only be set to true when MACAddressPolicy= is set to 'random' (see systemd.link5). When true, ClientIdentifier=mac, RapidCommit=no, SendHostname=no, Use6RD=no, UseCaptivePortal=no, UseMTU=no, UseNTP=no, UseSIP=no, and UseTimezone=no are implied and these settings in the.network file are silently ignored. Also, Hostname=, MUDURL=, RequestAddress=, RequestOptions=, SendOption=, SendVendorOption=, UserClass=, and VendorClassIdentifier= are silently ignored. With this option enabled DHCP requests will mimic those generated by Microsoft Windows, in order to reduce the ability to fingerprint and recognize installations. This means DHCP request sizes will grow and lease data will be more comprehensive than normally, though most of the requested data is not actually used."
              },
              "SendHostname": {
                "type": "boolean",
                "description": "When true (the default), the machine's hostname (or the value specified with Hostname=, described below) will be sent to the DHCP server. Note that the hostname must consist only of 7-bit ASCII lower-case characters and no spaces or dots, and be formatted as a valid DNS domain name. Otherwise, the hostname is not sent even if this option is true."
              },
              "Hostname": {
                "type": "string",
                "description": "Use this value for the hostname which is sent to the DHCP server, instead of machine's hostname. Note that the specified hostname must consist only of 7-bit ASCII lower-case characters and no spaces or dots, and be formatted as a valid DNS domain name."
              },
              "RequestBroadcast": {
                "type": "boolean",
                "description": "Request the server to use broadcast messages before the IP address has been configured. This is necessary for devices that cannot receive RAW packets, or that cannot receive packets at all before an IP address has been configured. On the other hand, this must not be enabled on networks where broadcasts are filtered out."
              },
              "CriticalConnection": {
                "type": "boolean"
              },
              "VendorClassIdentifier": {
                "type": "string",
                "description": "The vendor class identifier used to identify vendor type and configuration."
              },
              "UserClass": {
                "type": "string",
                "description": "A DHCPv4 client can use UserClass option to identify the type or category of user or applications it represents. The information contained in this option is a string that represents the user class of which the client is a member. Each class sets an identifying string of information to be used by the DHCP service to classify clients. Takes a whitespace-separated list of strings."
              },
              "IAID": {
                "type": "integer",
                "minimum": 0,
                "maximum": 4294967295,
                "description": "The DHCP Identity Association Identifier (IAID) for the interface, a 32-bit unsigned integer."
              },
              "DUIDType": {
                "type": "string",
                "description": "Override the global DUIDType= setting for this network. See networkd.conf5 for a description of possible values."
              },
              "DUIDRawData": {
                "type": "string",
                "description": "Override the global DUIDRawData= setting for this network. See networkd.conf5 for a description of possible values."
              },
              "RouteMetric": {
                "type": "integer",
                "minimum": 0,
                "maximum": 4294967295,
                "description": "The metric of the prefix route, which is pointing to the subnet of the configured IP address, taking the configured prefix length into account. Takes an unsigned integer in the range 0...4294967295. When unset or set to 0, the kernel's default value is used. This setting will be ignored when AddPrefixRoute= is false."
              },
              "RouteTable": {
                "oneOf": [
                  {
                    "type": "string",
                    "enum": [
                      "default",
                      "local",
                      "main"
                    ]
                  },
                  {
                    "type": "integer",
                    "minimum": 1,
                    "maximum": 4294967295
                  }
                ],
                "description": "The table identifier for DHCP routes. conf5, or a number between 1...4294967295. When used in combination with VRF=, the VRF's routing table is used when this parameter is not specified."
              },
              "UseTimezone": {
                "type": "boolean",
                "default": false,
                "description": "When true, the timezone received from the DHCP server will be set as timezone of the local system. Defaults to false."
              },
              "ListenPort": {
                "type": "integer",
                "minimum": 1,
                "maximum": 65535,
                "description": "Set the port from which the DHCP client packets originate."
              },
              "RapidCommit": {
                "type": "boolean",
                "default": true,
                "description": "The DHCPv4 client can obtain configuration parameters from a DHCPv4 server through a rapid two-message exchange (discover and ack). When the rapid commit option is set by both the DHCPv4 client and the DHCPv4 server, the two-message exchange is used. Otherwise, the four-message exchange (discover, offer, request, and ack) is used. The two-message exchange provides faster client configuration. See RFC 4039 for details. Defaults to true when Anonymize=no and neither AllowList= nor DenyList= is specified, and false otherwise."
              },
              "ForceDHCPv6PDOtherInformation": {
                "type": "boolean",
                "default": false,
                "description": "When true, the 'Other Configuration' flag in the DHCPv6 Request is set. Defaults to false."
              }
            },
            "additionalProperties": false
          }
        },
        {
          "type": "object",
          "description": "[DHCP] section configuration",
          "properties": {
            "ClientIdentifier": {
              "type": "string",
              "enum": [
                "duid",
                "mac"
              ],
              "default": "duid",
              "description": "The DHCPv4 client identifier to use. If set to 'mac', the MAC address of the link is used. If set to 'duid', an RFC4361-compliant Client ID, which is the combination of IAID and DUID, is used. IAID can be configured by IAID=. DUID can be configured by DUIDType= and DUIDRawData=. Defaults to 'duid'."
            },
            "UseDNS": {
              "type": "boolean",
              "description": "When true (the default), the DNS servers received from the DHCP server will be used. This corresponds to the 'nameserver' option in resolv.conf5."
            },
            "UseNTP": {
              "type": "boolean",
              "description": "When true (the default), the NTP servers received from the DHCP server will be used by 'systemd-timesyncd.service'."
            },
            "UseMTU": {
              "type": "boolean",
              "default": false,
              "description": "When true, the interface maximum transmission unit from the DHCP server will be used on the current link. If MTUBytes= is set, then this setting is ignored. Defaults to false. Note, some drivers will reset the interfaces if the MTU is changed. For such interfaces, please try to use IgnoreCarrierLoss= with a short timespan, e.g. '3 seconds'."
            },
            "UseHostname": {
              "type": "boolean",
              "description": "When true (the default), the hostname received from the DHCP server will be set as the transient hostname of the system."
            },
            "UseDomains": {
              "type": "boolean",
              "description": "Specifies the protocol-independent default value for the same settings in [IPv6AcceptRA], [DHCPv4], and [DHCPv6] sections below. Takes a boolean, or the special value 'route'. See also the same setting in [DHCPv4] below. Defaults to unset."
            },
            "UseDomainName": {
              "type": "string"
            },
            "UseRoutes": {
              "type": "boolean",
              "description": "When true (the default), the static routes will be requested from the DHCP server and added to the routing table with a metric of 1024, and a scope of 'global', 'link' or 'host', depending on the route's destination and gateway. If the destination is on the local host, e.g., 127.x.x.x, or the same as the link's own address, the scope will be set to 'host'. Otherwise if the gateway is null (a direct route), a 'link' scope will be used. For anything else, scope defaults to 'global'."
            },
            "Anonymize": {
              "type": "boolean",
              "default": false,
              "description": "When true, the options sent to the DHCP server will follow the RFC 7844 (Anonymity Profiles for DHCP Clients) to minimize disclosure of identifying information. Defaults to false. This option should only be set to true when MACAddressPolicy= is set to 'random' (see systemd.link5). When true, ClientIdentifier=mac, RapidCommit=no, SendHostname=no, Use6RD=no, UseCaptivePortal=no, UseMTU=no, UseNTP=no, UseSIP=no, and UseTimezone=no are implied and these settings in the.network file are silently ignored. Also, Hostname=, MUDURL=, RequestAddress=, RequestOptions=, SendOption=, SendVendorOption=, UserClass=, and VendorClassIdentifier= are silently ignored. With this option enabled DHCP requests will mimic those generated by Microsoft Windows, in order to reduce the ability to fingerprint and recognize installations. This means DHCP request sizes will grow and lease data will be more comprehensive than normally, though most of the requested data is not actually used."
            },
            "SendHostname": {
              "type": "string",
              "description": "When true (the default), the machine's hostname (or the value specified with Hostname=, described below) will be sent to the DHCP server. Note that the hostname must consist only of 7-bit ASCII lower-case characters and no spaces or dots, and be formatted as a valid DNS domain name. Otherwise, the hostname is not sent even if this option is true."
            },
            "Hostname": {
              "type": "string",
              "description": "Use this value for the hostname which is sent to the DHCP server, instead of machine's hostname. Note that the specified hostname must consist only of 7-bit ASCII lower-case characters and no spaces or dots, and be formatted as a valid DNS domain name."
            },
            "RequestBroadcast": {
              "type": "boolean",
              "description": "Request the server to use broadcast messages before the IP address has been configured. This is necessary for devices that cannot receive RAW packets, or that cannot receive packets at all before an IP address has been configured. On the other hand, this must not be enabled on networks where broadcasts are filtered out."
            },
            "CriticalConnection": {
              "type": "boolean"
            },
            "VendorClassIdentifier": {
              "type": "string",
              "description": "The vendor class identifier used to identify vendor type and configuration."
            },
            "UserClass": {
              "type": "string",
              "description": "A DHCPv4 client can use UserClass option to identify the type or category of user or applications it represents. The information contained in this option is a string that represents the user class of which the client is a member. Each class sets an identifying string of information to be used by the DHCP service to classify clients. Takes a whitespace-separated list of strings."
            },
            "IAID": {
              "type": "integer",
              "minimum": 0,
              "maximum": 4294967295,
              "description": "The DHCP Identity Association Identifier (IAID) for the interface, a 32-bit unsigned integer."
            },
            "DUIDType": {
              "type": "string",
              "description": "Override the global DUIDType= setting for this network. See networkd.conf5 for a description of possible values."
            },
            "DUIDRawData": {
              "type": "string",
              "description": "Override the global DUIDRawData= setting for this network. See networkd.conf5 for a description of possible values."
            },
            "RouteMetric": {
              "type": "integer",
              "minimum": 0,
              "maximum": 4294967295,
              "description": "The metric of the prefix route, which is pointing to the subnet of the configured IP address, taking the configured prefix length into account. Takes an unsigned integer in the range 0...4294967295. When unset or set to 0, the kernel's default value is used. This setting will be ignored when AddPrefixRoute= is false."
            },
            "RouteTable": {
              "oneOf": [
                {
                  "type": "string",
                  "enum": [
                    "default",
                    "local",
                    "main"
                  ]
                },
                {
                  "type": "integer",
                  "minimum": 1,
                  "maximum": 4294967295
                }
              ],
              "description": "The table identifier for DHCP routes. conf5, or a number between 1...4294967295. When used in combination with VRF=, the VRF's routing table is used when this parameter is not specified."
            },
            "UseTimezone": {
              "type": "boolean",
              "default": false,
              "description": "When true, the timezone received from the DHCP server will be set as timezone of the local system. Defaults to false."
            },
            "ListenPort": {
              "type": "integer",
              "minimum": 1,
              "maximum": 65535,
              "description": "Set the port from which the DHCP client packets originate."
            },
            "RapidCommit": {
              "type": "boolean",
              "default": true,
              "description": "The DHCPv4 client can obtain configuration parameters from a DHCPv4 server through a rapid two-message exchange (discover and ack). When the rapid commit option is set by both the DHCPv4 client and the DHCPv4 server, the two-message exchange is used. Otherwise, the four-message exchange (discover, offer, request, and ack) is used. The two-message exchange provides faster client configuration. See RFC 4039 for details. Defaults to true when Anonymize=no and neither AllowList= nor DenyList= is specified, and false otherwise."
            },
            "ForceDHCPv6PDOtherInformation": {
              "type": "boolean",
              "default": false,
              "description": "When true, the 'Other Configuration' flag in the DHCPv6 Request is set. Defaults to false."
            }
          },
          "additionalProperties": false
        }
      ],
      "description": "[DHCP] configuration (Can be repeated)",
      "title": "DHCP",
      "examples": [
        "yes",
        "no",
        "ipv4",
        "ipv6"
      ]
    },
    "TrafficControlQueueingDiscipline": {
      "oneOf": [
        {
          "type": "array",
          "items": {
            "type": "object",
            "description": "[TrafficControlQueueingDiscipline] section configuration",
            "properties": {
              "Parent": {
                "$ref": "#/definitions/qdisc_parent"
              },
              "NetworkEmulatorDelaySec": {
                "allOf": [
                  {
                    "$ref": "#/definitions/seconds"
                  }
                ]
              },
              "NetworkEmulatorDelayJitterSec": {
                "allOf": [
                  {
                    "$ref": "#/definitions/seconds"
                  }
                ]
              },
              "NetworkEmulatorLossRate": {
                "allOf": [
                  {
                    "$ref": "#/definitions/percentage"
                  }
                ]
              },
              "NetworkEmulatorDuplicateRate": {
                "allOf": [
                  {
                    "$ref": "#/definitions/percentage"
                  }
                ]
              },
              "NetworkEmulatorPacketLimit": {
                "allOf": [
                  {
                    "$ref": "#/definitions/uint32"
                  }
                ]
              }
            },
            "additionalProperties": false,
            "required": [
              "Parent"
            ]
          }
        },
        {
          "type": "object",
          "description": "[TrafficControlQueueingDiscipline] section configuration",
          "properties": {
            "Parent": {
              "$ref": "#/definitions/qdisc_parent"
            },
            "NetworkEmulatorDelaySec": {
              "allOf": [
                {
                  "$ref": "#/definitions/seconds"
                }
              ]
            },
            "NetworkEmulatorDelayJitterSec": {
              "allOf": [
                {
                  "$ref": "#/definitions/seconds"
                }
              ]
            },
            "NetworkEmulatorLossRate": {
              "allOf": [
                {
                  "$ref": "#/definitions/percentage"
                }
              ]
            },
            "NetworkEmulatorDuplicateRate": {
              "allOf": [
                {
                  "$ref": "#/definitions/percentage"
                }
              ]
            },
            "NetworkEmulatorPacketLimit": {
              "allOf": [
                {
                  "$ref": "#/definitions/uint32"
                }
              ]
            }
          },
          "additionalProperties": false,
          "required": [
            "Parent"
          ]
        }
      ],
      "description": "[TrafficControlQueueingDiscipline] configuration (Can be repeated)",
      "title": "Traffic Control Queueing Discipline"
    }
  }
}